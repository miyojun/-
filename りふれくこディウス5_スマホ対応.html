<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AIコーチ VS 学習しない組織 (v15 - スタート処理修正)</title> {/* タイトル更新 */}
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        /* 基本スタイル */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* スクロールバーを隠す */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* ゲームコンテナ */
        #gameContainer {
            position: relative; /* ボタン配置の基準 */
            width: 95vw;
            max-width: 960px;
            aspect-ratio: 16 / 10;
            max-height: 90vh;
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden;
            margin: 10px auto;
            box-sizing: border-box;
        }

        /* キャンバス */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111;
            image-rendering: pixelated;
        }

        /* パワーアップバー */
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: clamp(3px, 0.8vw, 5px);
            border: 2px solid #fff;
            border-radius: 5px;
            width: 95vw; /* JSで上書き */
            max-width: 960px;
            box-sizing: border-box;
            margin: 5px auto 0;
            flex-wrap: wrap;
            gap: clamp(3px, 0.5vw, 5px);
        }
        .powerUpItem {
            padding: clamp(3px, 0.8vw, 5px) clamp(5px, 1vw, 10px);
            border: 1px solid #555;
            color: #888;
            font-size: clamp(8px, 1.5vw, 12px);
            cursor: default;
            transition: all 0.2s ease;
            text-align: center;
            min-width: clamp(60px, 10vw, 90px);
            white-space: nowrap;
            flex-grow: 1;
            flex-basis: 80px;
        }
        .powerUpItem.highlighted { background-color: #ffcc00; color: #000; border-color: #fff; box-shadow: 0 0 10px #ffcc00; }
        .powerUpItem.active { background-color: #ff6600; color: #fff; border-color: #fff; }

        /* UIレイヤー */
        #uiLayer {
            position: absolute;
            top: clamp(5px, 1vw, 10px);
            left: clamp(5px, 1vw, 10px);
            right: clamp(5px, 1vw, 10px);
            display: flex;
            justify-content: space-between;
            font-size: clamp(10px, 2vw, 16px);
            pointer-events: none;
            text-shadow: 1px 1px 2px #000;
            z-index: 2; /* ボタンより手前 */
        }

        /* ボスHPバー */
        #bossHpBar {
            position: absolute;
            bottom: clamp(5px, 1vw, 10px);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 300px);
            height: clamp(10px, 1.5vh, 15px);
            border: 2px solid #fff;
            background-color: #555;
            display: none;
            z-index: 5; /* メッセージより奥、他より手前 */
        }
        #bossHpFill { width: 100%; height: 100%; background-color: #ff4444; transition: width 0.2s ease-out; }

        /* メッセージボックス */
        #messageBox {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: clamp(15px, 3vw, 30px);
            border: 2px solid white;
            border-radius: 10px;
            font-size: clamp(16px, 3.5vw, 24px);
            text-align: center;
            display: none; /* 初期は非表示 JSで表示 */
            z-index: 10; /* 最前面 */
            width: 80%;
            max-width: 500px;
            box-sizing: border-box;
        }
        #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.5vw, 16px);
            padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px);
            margin-top: clamp(10px, 2vh, 20px);
            cursor: pointer;
            background-color: #ffcc00;
            border: 2px solid #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #messageBox button:hover { background-color: #ffa500; }

        /* タッチ操作ボタンのスタイル */
        .touch-button {
            position: absolute;
            bottom: clamp(10px, 3vh, 20px); /* 下からの位置 */
            width: clamp(60px, 15vw, 90px); /* 可変幅 */
            height: clamp(60px, 15vw, 90px); /* 可変高さ */
            background-color: rgba(255, 255, 255, 0.2); /* 半透明 */
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%; /* 円形 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(10px, 2vw, 14px);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            z-index: 3; /* UIより手前、メッセージより奥 */
            box-sizing: border-box;
            text-align: center;
            line-height: 1.2;
        }
        .touch-button:active { /* 押下時のスタイル */
            background-color: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
        }
        #touchShoot {
            right: clamp(10px, 3vw, 20px); /* 右からの位置 */
        }
        #touchPowerup {
            left: clamp(10px, 3vw, 20px); /* 左からの位置 */
        }


        /* メディアクエリ */
        @media (max-width: 960px) and (orientation: landscape) { }
         @media (max-height: 480px) {
             #gameContainer { max-height: 95vh; }
             #powerUpBar { margin-top: 3px; }
             #uiLayer, #bossHpBar { font-size: clamp(8px, 2vw, 12px); }
             .touch-button {
                width: clamp(50px, 13vw, 70px);
                height: clamp(50px, 13vw, 70px);
                bottom: clamp(5px, 2vh, 10px);
             }
             #touchShoot { right: clamp(5px, 2vw, 10px); }
             #touchPowerup { left: clamp(5px, 2vw, 10px); }
         }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 💖💖💖</div>
        </div>
         <div id="bossHpBar"> <div id="bossHpFill"></div>
         </div>
         <div id="messageBox">
             <div id="messageText"></div>
             {/* ボタンのIDは restartButton のまま */}
             <button id="restartButton">RESTART</button>
         </div>
         <div id="touchShoot" class="touch-button">SHOOT</div>
         <div id="touchPowerup" class="touch-button">ACTIVATE<br>POWERUP</div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="productivity">生産性UP</div>
        <div class="powerUpItem" id="inquiry">問いかけ</div>
        <div class="powerUpItem" id="aiFeedback">AIフィードバック</div>
        <div class="powerUpItem" id="learningBeam">経験学習ビーム</div>
        <div class="powerUpItem" id="aiAgent">AIエージェント</div>
        <div class="powerUpItem" id="safety">心理的安全性</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        // ▼▼▼ restartButton は init 内で取得し直すので、ここでは宣言不要 ▼▼▼
        // const restartButton = document.getElementById('restartButton');
        // ▲▲▲ restartButton は init 内で取得し直すので、ここでは宣言不要 ▲▲▲
        const bossHpBar = document.getElementById('bossHpBar');
        const bossHpFill = document.getElementById('bossHpFill');
        const touchShootButton = document.getElementById('touchShoot');
        const touchPowerupButton = document.getElementById('touchPowerup');

        let gameWidth, gameHeight;
        let stars = [];

        // --- 画像読み込み ---
        const playerImage = new Image(); playerImage.src = 'refleko_right.png';
        let playerImageLoaded = false; playerImage.onload = () => { playerImageLoaded = true; }; playerImage.onerror = () => { console.error("プレイヤー画像の読み込みに失敗しました。"); playerImage.src = 'https://placehold.co/40x40/0f0/fff?text=P'; };
        const optionImage = new Image(); optionImage.src = 'reflect_logo_3.png';
        let optionImageLoaded = false; optionImage.onload = () => { optionImageLoaded = true; }; optionImage.onerror = () => { console.error("オプション画像の読み込みに失敗しました。"); optionImage.src = 'https://placehold.co/38x38/0af/fff?text=O'; };
        const bossImage = new Image(); bossImage.src = 'bigwork.png';
        let bossImageLoaded = false;
        bossImage.onload = () => { bossImageLoaded = true; }; bossImage.onerror = () => { console.error("ボス画像の読み込みに失敗しました。"); bossImage.src = 'https://placehold.co/200x200/800/fff?text=BOSS'; };


        // --- 音声設定 ---
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
        const bombSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.4, attackCurve: 'exponential' } }).toDestination();

        function playSound(type) {
             if (!Tone.context.state || Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); }
             try { switch (type) { case 'shoot': synth.triggerAttackRelease("C5", "16n"); break; case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break; case 'playerHit': metalSynth.triggerAttackRelease("16n"); break; case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break; case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break; case 'gameOver': synth.triggerAttackRelease("C3", "4n", Tone.now()); synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4); synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6); break; case 'missile': const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); missileNoise.triggerAttackRelease("8n"); break; case 'laser': synth.triggerAttackRelease("A5", "64n"); break; case 'enemyShoot': bombSynth.triggerAttackRelease("C2", "8n"); break; case 'bossHit': metalSynth.triggerAttackRelease("8n", 0.5); break; case 'bossDefeat': synth.triggerAttackRelease("C6", "2n", Tone.now()); synth.triggerAttackRelease("G5", "2n", Tone.now()+0.1); synth.triggerAttackRelease("E5", "2n", Tone.now()+0.2); synth.triggerAttackRelease("C5", "1n", Tone.now()+0.3); break; } } catch (error) { console.error("Error playing sound:", error); }
        }

        // --- ゲーム設定 ---
        let PLAYER_WIDTH = 40; let PLAYER_HEIGHT = 40; const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7; const PROJECTILE_FONT_SIZE = 20;
        const ENEMY_SPEED_BASE = 2; const ENEMY_SPAWN_RATE = 1000; const ENEMY_FONT_SIZE = 18;
        const ENEMY_PROJECTILE_SPEED = 3; const ENEMY_PROJECTILE_FONT_SIZE = 18;
        const POWERUP_ITEM_SPEED = 1.5; const POWERUP_ITEM_WIDTH = 12; const POWERUP_ITEM_HEIGHT = 20;
        const MISSILE_SPEED = 4; const MISSILE_FONT_SIZE = 20;
        const OPTION_WIDTH = 38; const OPTION_HEIGHT = 38;
        const ORBIT_RADIUS = 55;
        const ORBIT_SPEED = 0.05;
        const STAR_COUNT = 100; const STAR_SPEED_FACTOR = 0.5;
        const PLANET_SPAWN_RATE = 8000; const PLANET_SPEED = 0.5;
        const LASER_TEXT = "経験学習-".repeat(7); const LASER_FONT_SIZE = 14;
        const BOSS_TRIGGER_SCORE = 15000;
        const BOSS_WIDTH = 200; const BOSS_HEIGHT = 200; const BOSS_MAX_HEALTH = 150;
        const BOSS_SHOOT_COOLDOWN = 1500; const BOSS_SCORE = 5000;
        const TOUCH_SHOOT_INTERVAL = 100;

        // --- ゲーム状態 ---
        let player; let projectiles = []; let enemyProjectiles = []; let missiles = []; let enemies = []; let powerUpItemsList = []; let options = []; let terrain = [];
        let score = 0; let lives = 3; let gameOver = false; let gameWon = false;
        let gameRunning = false;
        let lastEnemySpawn = 0; lastPlanetSpawn = 0;
        let keys = {}; let currentPowerUpIndex = -1;
        let activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false };
        let shieldHp = 0;
        let laserActive = false;
        let enemySpawnPool = [];
        let bossModeActive = false;
        let boss = null;
        let shootInterval = null;

        const powerUpTypes = ['productivity', 'inquiry', 'aiFeedback', 'learningBeam', 'aiAgent', 'safety'];

        // --- 敵の種類定義 ---
        const enemyTypes = { shortage: { text: "人手不足", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffdddd', health: 2, speedMultiplier: 0.9, value: 120, moveType: 'straight', dropChance: 0.15 * 1.5 }, powerH:   { text: "パワハラ", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffaaaa', health: 1, speedMultiplier: 1.2, value: 150, moveType: 'sine', dropChance: 0.2 * 1.5 }, overtime: { text: "残業",   width: ENEMY_FONT_SIZE * 2, height: ENEMY_FONT_SIZE * 1.2, color: '#ddddff', health: 3, speedMultiplier: 0.7, value: 100, moveType: 'straight', dropChance: 0.1 * 1.5 }, sexualH:  { text: "セクハラ", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffccff', health: 1, speedMultiplier: 1.1, value: 140, moveType: 'sine', dropChance: 0.18 * 1.5 }, turnover: { text: "高離職率", width: ENEMY_FONT_SIZE * 5, height: ENEMY_FONT_SIZE * 1.2, color: '#ffffcc', health: 2, speedMultiplier: 1.0, value: 130, moveType: 'straight', dropChance: 0.22 * 1.5 }, nonLearningOrg: { text: "学習しない組織", width: ENEMY_FONT_SIZE * 7, height: ENEMY_FONT_SIZE * 1.2, color: '#aaaaaa', health: 5, speedMultiplier: 0.6, value: 300, moveType: 'straight', dropChance: 0.15 * 1.5 }, resistance: { text: "抵抗勢力", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#cc5555', health: 2, speedMultiplier: 0.5, value: 180, moveType: 'shooter', dropChance: 0.2 * 1.5, shootCooldown: 2500 } };

        // --- プレイヤークラス ---
        class Player {
            constructor(x, y) { this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT; this.speed = PLAYER_SPEED_BASE; this.shootCooldown = 0; this.missileCooldown = 0; this.laserDuration = 0; this.invincible = false; this.invincibleTimer = 0; }
            draw(ctx) { let drawPlayer = true; if (this.invincible) { drawPlayer = Math.floor(this.invincibleTimer / 100) % 2 === 0; } if (drawPlayer) { if (playerImageLoaded) { ctx.drawImage(playerImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10); ctx.fillStyle = '#000000'; ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10); } } if (activePowerUps.safety && shieldHp > 0) { ctx.save(); ctx.globalAlpha = 0.5 + shieldHp * 0.25; ctx.strokeStyle = `rgba(0, 150, 255, 1)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1; } }
            update() { if (this.invincible) { this.invincibleTimer -= 1000/60; if (this.invincibleTimer <= 0) { this.invincible = false; } } if (keys['ArrowUp'] || keys['w']) this.y -= this.speed; if (keys['ArrowDown'] || keys['s']) this.y += this.speed; if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed; if (keys['ArrowRight'] || keys['d']) this.x += this.speed; this.x = Math.max(0, Math.min(this.x, gameWidth - this.width)); this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); if (this.shootCooldown > 0) this.shootCooldown -= 16.67; if (this.missileCooldown > 0) this.missileCooldown -= 16.67; if (this.laserDuration > 0) this.laserDuration -= 16.67; else laserActive = false; if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) { this.shoot(); } if (activePowerUps.inquiry && this.missileCooldown <= 0) { this.fireMissile(); this.missileCooldown = 800; } options.forEach((option, index) => { option.update(this.x, this.y, index); }); }
            shoot() { if (gameOver || gameWon || !gameRunning) return; this.shootCooldown = activePowerUps.learningBeam ? 50 : 200; const projectileY = this.y + this.height / 2; if (activePowerUps.learningBeam) { laserActive = true; this.laserDuration = 150; playSound('laser'); } else { projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', 0, '💬', PROJECTILE_FONT_SIZE)); playSound('shoot'); if (activePowerUps.aiFeedback) { projectiles.push(new Projectile(this.x + this.width, projectileY - 10, 'player', Math.PI / 18, '💬', PROJECTILE_FONT_SIZE)); projectiles.push(new Projectile(this.x + this.width, projectileY + 10, 'player', -Math.PI / 18, '💬', PROJECTILE_FONT_SIZE)); } } options.forEach(option => option.shoot(activePowerUps.learningBeam)); }
            fireMissile() { if (gameOver || gameWon || !gameRunning) return; missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down')); missiles.push(new Missile(this.x + this.width / 2, this.y, 'up')); playSound('missile'); }
            activatePowerUp() { if (gameOver || gameWon || !gameRunning) return; if (currentPowerUpIndex !== -1) { const selectedPowerUp = powerUpTypes[currentPowerUpIndex]; playSound('powerupActivate'); switch (selectedPowerUp) { case 'productivity': activePowerUps.productivity++; this.speed = PLAYER_SPEED_BASE + activePowerUps.productivity * 1; break; case 'inquiry': activePowerUps.inquiry = true; break; case 'aiFeedback': activePowerUps.aiFeedback = true; activePowerUps.learningBeam = false; break; case 'learningBeam': activePowerUps.learningBeam = true; activePowerUps.aiFeedback = false; break; case 'aiAgent': if (activePowerUps.aiAgent < 2) { activePowerUps.aiAgent++; options.push(new Option(options.length)); } break; case 'safety': activePowerUps.safety = true; shieldHp = 2; break; } updatePowerUpUI(); currentPowerUpIndex = -1; highlightPowerUp(); } }
            hit() { if (this.invincible || gameWon) return; playSound('playerHit'); if (activePowerUps.safety && shieldHp > 0) { shieldHp--; this.setInvincible(500); if (shieldHp <= 0) { activePowerUps.safety = false; const safetyElement = document.getElementById('safety'); if (safetyElement) safetyElement.classList.remove('active'); } updatePowerUpUI(); return; } lives--; updateLivesDisplay(); resetPowerUps(); if (lives <= 0) { gameOver = true; playSound('gameOver'); showGameOverMessage(); } else { this.x = 50; this.y = gameHeight / 2 - PLAYER_HEIGHT / 2; this.setInvincible(2000); } }
            setInvincible(duration) { this.invincible = true; this.invincibleTimer = duration; }
        }

        // --- 弾クラス ---
        class Projectile { constructor(x, y, type, angle = 0, text = '?', fontSize = 16, speed = PROJECTILE_SPEED) { this.x = x; this.y = y; this.fontSize = fontSize; this.width = this.fontSize; this.height = this.fontSize; this.speed = speed; this.type = type; this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.text = text; } draw(ctx) { ctx.font = `${this.fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.type === 'player' ? '#ffffff' : '#ff5555'; ctx.fillText(this.text, this.x, this.y); } update() { this.x += this.vx; this.y += this.vy; } }
        // --- ミサイルクラス ---
        class Missile { constructor(x, y, direction) { this.x = x; this.y = y; this.fontSize = MISSILE_FONT_SIZE; this.width = this.fontSize; this.height = this.fontSize; this.speed = MISSILE_SPEED; this.direction = direction; } draw(ctx) { ctx.font = `bold ${this.fontSize}px "Press Start 2P"`; ctx.fillStyle = '#ffcc00'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('？', this.x, this.y); } update() { if (this.direction === 'down') { this.y += this.speed; if (this.y > gameHeight - this.height / 2 - 5) { this.y = gameHeight - this.height / 2 - 5; this.x += this.speed / 2; this.direction = 'ground'; } } else { this.y -= this.speed; if (this.y < this.height / 2 + 5) { this.y = this.height / 2 + 5; this.x += this.speed / 2; this.direction = 'ceiling'; } } if (this.direction === 'ground' || this.direction === 'ceiling') { this.x += this.speed / 1.5; } } }
        // --- 敵クラス ---
        class Enemy { constructor(y, typeName) { const type = enemyTypes[typeName] || enemyTypes.shortage; this.typeName = typeName; this.text = type.text; this.width = type.width; this.height = type.height; this.x = gameWidth; this.y = y; this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; this.color = type.color; this.health = type.health; this.value = type.value; this.moveType = type.moveType; this.amplitude = Math.random() * 40 + 10; this.frequency = Math.random() * 0.04 + 0.01; this.initialY = y; this.canDropPowerUp = Math.random() < type.dropChance; if (this.moveType === 'shooter') { this.shootCooldown = type.shootCooldown + (Math.random() * 500 - 250); this.lastShotTime = 0; } } draw(ctx) { ctx.font = `bold ${ENEMY_FONT_SIZE}px "Press Start 2P"`; ctx.fillStyle = this.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(this.text, this.x, this.y); } update(timestamp) { this.x -= this.speed; if (this.moveType === 'sine') { this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); } else if (this.moveType === 'shooter' && player) { if (this.x < gameWidth * 0.9 && this.x > 0 && timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; this.shootCooldown = enemyTypes[this.typeName].shootCooldown + (Math.random() * 500 - 250); } } } shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const targetX = player.x + player.width / 2; const targetY = player.y + player.height / 2; const dx = targetX - (this.x); const dy = targetY - (this.y + this.height / 2); const angle = Math.atan2(dy, dx); enemyProjectiles.push(new Projectile( this.x, this.y + this.height / 2, 'enemy', angle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED )); } hit() { this.health--; if (this.health <= 0) { addScore(this.value); playSound('enemyHit'); if (this.canDropPowerUp) { dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); } return true; } const originalColor = this.color; this.color = '#ffffff'; setTimeout(() => { this.color = originalColor; }, 60); return false; } }
        // --- PowerUpItemクラス ---
        class PowerUpItem { constructor(x, y) { this.x = x - POWERUP_ITEM_WIDTH / 2; this.y = y - POWERUP_ITEM_HEIGHT / 2; this.width = POWERUP_ITEM_WIDTH; this.height = POWERUP_ITEM_HEIGHT; this.speed = POWERUP_ITEM_SPEED; this.colorTop = '#aaaaee'; this.colorBody = '#4444ff'; this.colorAccent = '#ff4444'; this.sparkleOffset = 0; this.sparkleSpeed = 0.1; } draw(ctx, timestamp) { const topHeight = this.height * 0.2; const bodyHeight = this.height * 0.6; const bottomHeight = this.height * 0.2; ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y, this.width, topHeight); ctx.fillStyle = this.colorBody; ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight); ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight); ctx.fillStyle = this.colorAccent; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2); ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("P", this.x + this.width / 2, this.y + this.height / 2 + 1); ctx.fillStyle = '#ffffaa'; const sparkleSize = 2; const sparkleDistance = Math.max(this.width, this.height) * 0.7; const angle1 = timestamp * 0.005 + this.sparkleOffset; const angle2 = timestamp * 0.005 + Math.PI / 2 + this.sparkleOffset; const angle3 = timestamp * 0.005 + Math.PI + this.sparkleOffset; const angle4 = timestamp * 0.005 + Math.PI * 1.5 + this.sparkleOffset; const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2; ctx.fillRect(centerX + Math.cos(angle1) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle1) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle2) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle2) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle3) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle3) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle4) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle4) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); } update() { this.x -= this.speed; } }
        // --- Optionクラス ---
        class Option { constructor(index = 0) { this.x = 0; this.y = 0; this.width = OPTION_WIDTH; this.height = OPTION_HEIGHT; this.size = Math.max(this.width, this.height); this.shootCooldown = 0; this.angle = index * Math.PI; } draw(ctx) { if (optionImageLoaded) { ctx.drawImage(optionImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } } update(playerX, playerY, index) { this.angle += ORBIT_SPEED; if (this.angle > Math.PI * 2) { this.angle -= Math.PI * 2; } const playerCenterX = playerX + PLAYER_WIDTH / 2; const playerCenterY = playerY + PLAYER_HEIGHT / 2; const currentOrbitAngle = this.angle + index * Math.PI; const targetX = playerCenterX + Math.cos(currentOrbitAngle) * ORBIT_RADIUS - this.width / 2; const targetY = playerCenterY + Math.sin(currentOrbitAngle) * ORBIT_RADIUS - this.height / 2; this.x = targetX; this.y = targetY; if (this.shootCooldown > 0) this.shootCooldown -= 16.67; } shoot(isLaser) { if (this.shootCooldown <= 0) { this.shootCooldown = 200; const projectileY = this.y + this.height / 2; const projectileX = this.x + this.width; if (isLaser) { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '?', PROJECTILE_FONT_SIZE)); playSound('laser'); } else { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '💬', PROJECTILE_FONT_SIZE)); playSound('shoot'); } } } }
        // --- Starクラス ---
        class Star { constructor() { this.x = Math.random() * gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; } draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } update() { this.x -= this.speed; if (this.x < 0) { this.x = gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; } } }
        // --- 地形クラス ---
        class Planet { constructor(y, radius, color, speed) { this.x = gameWidth + radius; this.y = y; this.radius = radius; this.color = color; this.speed = speed; } draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; const numCraters = Math.floor(this.radius / 10); for (let i = 0; i < numCraters; i++) { const craterRadius = Math.random() * (this.radius * 0.15) + (this.radius * 0.05); const angle = Math.random() * Math.PI * 2; const dist = Math.random() * (this.radius - craterRadius); const craterX = this.x + Math.cos(angle) * dist; const craterY = this.y + Math.sin(angle) * dist; ctx.beginPath(); ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2); ctx.fill(); } } update() { this.x -= this.speed; } checkCollisionWithRect(rect) { const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width)); const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height)); const distanceX = this.x - closestX; const distanceY = this.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); } checkCollisionWithPoint(point) { const distanceX = this.x - point.x; const distanceY = this.y - point.y; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); } }
        // --- ボスクラス ---
        class Boss { constructor() { this.width = BOSS_WIDTH; this.height = BOSS_HEIGHT; this.x = gameWidth; this.y = gameHeight / 2 - this.height / 2; this.speedX = 1.5; this.speedY = 1; this.maxHealth = BOSS_MAX_HEALTH; this.health = this.maxHealth; this.shootCooldown = BOSS_SHOOT_COOLDOWN; this.lastShotTime = 0; this.onScreen = false; this.targetY = this.y; this.hitFlashTimer = 0; } draw(ctx) { let currentImage = bossImage; if (this.hitFlashTimer > 0) { if (Math.floor(this.hitFlashTimer / 50) % 2 === 0) { ctx.globalAlpha = 0.5; } } if (bossImageLoaded) { ctx.drawImage(currentImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#880000'; ctx.fillRect(this.x, this.y, this.width, this.height); } ctx.globalAlpha = 1.0; bossHpBar.style.display = 'block'; const hpPercentage = Math.max(0, this.health / this.maxHealth) * 100; bossHpFill.style.width = `${hpPercentage}%`; } update(timestamp) { if (this.hitFlashTimer > 0) { this.hitFlashTimer -= 1000 / 60; } if (!this.onScreen) { this.x -= this.speedX; if (this.x <= gameWidth - this.width - 50) { this.x = gameWidth - this.width - 50; this.onScreen = true; this.lastShotTime = timestamp; } } else { this.y += this.speedY; if (this.y <= 0 || this.y + this.height >= gameHeight) { this.speedY *= -1; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); } if (timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; } } } shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const shootX = this.x; const shootY = this.y + this.height / 2; const angleToPlayer = Math.atan2(player.y + player.height / 2 - shootY, player.x + player.width / 2 - shootX); const spreadAngle = Math.PI / 9; enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer - spreadAngle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer + spreadAngle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); } hit() { if (this.health <= 0) return false; this.health--; playSound('bossHit'); this.hitFlashTimer = 150; if (this.health <= 0) { addScore(BOSS_SCORE); playSound('bossDefeat'); bossHpBar.style.display = 'none'; gameWon = true; showGameWonMessage(); return true; } return false; } }


        // --- 初期化 ---
        function init() {
            resizeCanvas();
            player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2);
            projectiles = []; enemyProjectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = []; terrain = [];
            score = 0; lives = 3; gameOver = false; gameWon = false;
            gameRunning = false; lastEnemySpawn = 0; lastPlanetSpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            bossModeActive = false; boss = null; bossHpBar.style.display = 'none';
            if (shootInterval) { clearInterval(shootInterval); shootInterval = null; }

            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none'; // メッセージボックスは隠す
            stars = []; for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            enemySpawnPool = []; Object.keys(enemyTypes).forEach(key => { const weight = (key === 'resistance') ? 1 : 2; for (let i = 0; i < weight; i++) { enemySpawnPool.push(key); } });

            // --- スタート/リスタートボタン処理 ---
            showStartMessage(); // ★ スタートメッセージを表示する
            const oldRestartButton = document.getElementById('restartButton');
            if (oldRestartButton) { // ボタンが存在する場合のみ処理
                const newRestartButton = oldRestartButton.cloneNode(true); // クローン作成
                newRestartButton.addEventListener('click', startGame); // ★ 新しいボタンにリスナーを追加
                oldRestartButton.parentNode.replaceChild(newRestartButton, oldRestartButton); // ボタンを置換
            } else {
                console.error("Restart button not found during init!");
            }

            // --- 他のイベントリスナー設定 ---
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp);
            window.removeEventListener('resize', handleResize); window.removeEventListener('orientationchange', handleResize);
            touchShootButton.removeEventListener('touchstart', handleShootStart);
            touchShootButton.removeEventListener('touchend', handleShootEnd);
            touchShootButton.removeEventListener('touchcancel', handleShootEnd);
            touchPowerupButton.removeEventListener('touchstart', handlePowerupActivate);

            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', handleResize); window.addEventListener('orientationchange', handleResize);
            touchShootButton.addEventListener('touchstart', handleShootStart, { passive: false });
            touchShootButton.addEventListener('touchend', handleShootEnd);
            touchShootButton.addEventListener('touchcancel', handleShootEnd);
            touchPowerupButton.addEventListener('touchstart', handlePowerupActivate, { passive: false });
        }

        // --- メッセージ表示関数 ---
        function showStartMessage() {
            messageText.innerHTML = "AIコーチ VS 学習しない組織<br>Arrow Keys/WASD: Move<br>Space/Z: Shoot<br>Shift/X: Activate PowerUp<br><br>PRESS START BUTTON<br>or TAP START"; // タップも促す
            const startButton = document.getElementById('restartButton'); // ここで取得
            if (startButton) { // ボタンが存在するか確認
               startButton.textContent = "START GAME";
            } else {
                console.error("Restart button not found in showStartMessage!");
            }
            messageBox.style.display = 'block'; // ★ メッセージボックスを表示
            gameRunning = false; // ゲームはまだ開始しない
            console.log("Showing start message."); // 確認用ログ
        }
        function showGameOverMessage() { /* ...変更なし... */ }
        function showGameWonMessage() { /* ...変更なし... */ }

        // --- ゲーム開始関数 ---
        function startGame() {
            console.log("startGame called"); // 確認用ログ
            if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); }
            messageBox.style.display = 'none'; // ★ メッセージボックスを隠す
            if (gameOver || gameWon) {
                // ゲームオーバー/クリア状態なら初期化は不要。initが呼ばれるのはリスタート時のみ
                // ただし、状態のリセットは必要
                gameOver = false; gameWon = false;
                // スコアやライフなどをリセットする必要があればここで行うか、initを呼ぶ設計にする
                // 現在はリスタート時にinitが呼ばれるので、ここでは状態フラグのリセットのみ
                // → init() を呼ぶ方が状態管理がシンプル
                 init(); // ★ やはりinitを呼んで状態を完全にリセットする
                 // init内で gameRunning = false になるので、ここで再度 true にする
                 gameRunning = true;
                 if (shootInterval) { clearInterval(shootInterval); shootInterval = null; }
                 requestAnimationFrame(gameLoop);
                 return; // init内で再度startGameが呼ばれるのを防ぐ（init内のリスナー設定による）
            }
            // 通常のスタート
            gameOver = false; gameWon = false; gameRunning = true;
            if (shootInterval) { clearInterval(shootInterval); shootInterval = null; }
            requestAnimationFrame(gameLoop);
        }

        // --- リサイズ処理 ---
        function resizeCanvas() { const containerWidth = gameContainer.clientWidth; const containerHeight = gameContainer.clientHeight; canvas.width = containerWidth; canvas.height = containerHeight; gameWidth = canvas.width; gameHeight = canvas.height; powerUpBar.style.width = `${containerWidth}px`; powerUpBar.style.maxWidth = '960px'; stars.forEach(star => { star.x = Math.min(star.x, gameWidth); star.y = Math.min(star.y, gameHeight); }); console.log(`Resized canvas to: ${gameWidth}x${gameHeight}`); }
        let resizeTimeout;
        function handleResize() { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { resizeCanvas(); if (player) { player.x = Math.min(player.x, gameWidth - player.width); player.y = Math.min(player.y, gameHeight - player.height); } }, 100); }

        // --- パワーアップ処理 ---
        function collectPowerUp() { playSound('powerupCollect'); currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; highlightPowerUp(); }
        function highlightPowerUp() { powerUpItems.forEach((item, index) => { item.classList.toggle('highlighted', index === currentPowerUpIndex); }); }
        function updatePowerUpUI() { powerUpTypes.forEach((type) => { const element = document.getElementById(type); if (element) { let isActive = false; let text = element.textContent.split(' (')[0]; switch(type) { case 'productivity': isActive = activePowerUps.productivity > 0; text = isActive ? `生産性UP (${activePowerUps.productivity})` : '生産性UP'; break; case 'aiAgent': isActive = activePowerUps.aiAgent > 0; text = isActive ? `AIエージェント (${activePowerUps.aiAgent})` : 'AIエージェント'; break; case 'safety': isActive = activePowerUps.safety; text = isActive ? `心理的安全性 (${shieldHp})` : '心理的安全性'; break; case 'inquiry': isActive = activePowerUps.inquiry; text = '問いかけ'; break; case 'aiFeedback': isActive = activePowerUps.aiFeedback; text = 'AIフィードバック'; break; case 'learningBeam': isActive = activePowerUps.learningBeam; text = '経験学習ビーム'; break; } element.classList.toggle('active', isActive); element.textContent = text; } }); }
        function resetPowerUps(updateUI = true) { activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false }; if (player) player.speed = PLAYER_SPEED_BASE; options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1; if(updateUI) { updatePowerUpUI(); highlightPowerUp(); } }
        function dropPowerUpItem(x, y) { powerUpItemsList.push(new PowerUpItem(x, y)); }

        // --- スコア・ライフ更新 ---
        function addScore(amount) { if (gameOver || gameWon) return; score += amount; updateScoreDisplay(); if (!bossModeActive && score >= BOSS_TRIGGER_SCORE) { bossModeActive = true; enemies = []; terrain = []; enemyProjectiles = []; powerUpItemsList = []; boss = new Boss(); console.log("BOSS MODE ACTIVATED!"); } }
        function updateScoreDisplay() { scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { livesDisplay.innerHTML = `LIVES: ${'💖'.repeat(lives)}`; }

        // --- 衝突判定 ---
        function checkCollisions() { if (!player) return; terrain.forEach(planet => { if (!player.invincible && planet.checkCollisionWithRect(player)) { player.hit(); } projectiles = projectiles.filter(proj => !(proj.type === 'player' && planet.checkCollisionWithPoint(proj))); enemyProjectiles = enemyProjectiles.filter(proj => !planet.checkCollisionWithPoint(proj)); missiles = missiles.filter(missile => !planet.checkCollisionWithPoint({ x: missile.x, y: missile.direction === 'down' ? missile.y + missile.height : missile.y - missile.height })); }); projectiles = projectiles.filter(proj => { if (proj.type !== 'player') return true; const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(projHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; } } if (boss && boss.onScreen && isColliding(projHitbox, boss)) { if (boss.hit()) { boss = null; } return false; } return proj.x < gameWidth + proj.width; }); enemyProjectiles = enemyProjectiles.filter(proj => { const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height }; if (!player.invincible && isColliding(projHitbox, player)) { player.hit(); return false; } return proj.x > -proj.width && proj.x < gameWidth + proj.width && proj.y > -proj.height && proj.y < gameHeight + proj.height; }); missiles = missiles.filter(missile => { const missileHitbox = { x: missile.x - missile.width / 2, y: missile.y - missile.height / 2, width: missile.width, height: missile.height }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(missileHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; } } if (boss && boss.onScreen && isColliding(missileHitbox, boss)) { if (boss.hit()) { boss = null; } return false; } return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height; }); if (!player.invincible) { enemies.forEach((enemy, index) => { if (isColliding(player, enemy)) { player.hit(); if (enemy.hit()) { enemies.splice(index, 1); } } }); if (boss && boss.onScreen && isColliding(player, boss)) { player.hit(); } } powerUpItemsList = powerUpItemsList.filter(item => { if (isColliding(player, item)) { collectPowerUp(); return false; } return item.x > -item.width; }); }
        function isColliding(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- キーボード入力 ---
        function handleKeyDown(e) { if (!gameRunning && messageBox.style.display === 'block') { if (e.key === 'Shift' || e.key.toLowerCase() === 'x') { e.preventDefault(); return; } if (e.key === ' ' || e.key.toLowerCase() === 'z') { e.preventDefault(); return; } } else if (gameRunning) { keys[e.key] = true; if ((e.key === 'Shift' || e.key.toLowerCase() === 'x') && !e.repeat) { player.activatePowerUp(); } if (e.key === ' ' || e.key.toLowerCase() === 'z') { keys[e.key] = true; } } if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'x', 'w', 'a', 's', 'd'].includes(e.key)) { e.preventDefault(); } }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- タッチイベントハンドラ ---
        function handleShootStart(event) { event.preventDefault(); if (!gameRunning || gameOver || gameWon || shootInterval) return; shootInterval = setInterval(() => { if (player && gameRunning && !gameOver && !gameWon) { player.shoot(); } else { clearInterval(shootInterval); shootInterval = null; } }, TOUCH_SHOOT_INTERVAL); if (player && gameRunning && !gameOver && !gameWon) { player.shoot(); } }
        function handleShootEnd(event) { if (shootInterval) { clearInterval(shootInterval); shootInterval = null; } }
        function handlePowerupActivate(event) { event.preventDefault(); if (!gameRunning || gameOver || gameWon) return; if (player) { player.activatePowerUp(); } }

        // --- ゲームループ ---
        function gameLoop(timestamp) {
            if (gameOver || gameWon || !gameRunning) { if (shootInterval) { clearInterval(shootInterval); shootInterval = null; } return; }
            if (!bossModeActive) { if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) { lastEnemySpawn = timestamp; if (enemySpawnPool.length > 0) { const randomPoolIndex = Math.floor(Math.random() * enemySpawnPool.length); const randomTypeKey = enemySpawnPool[randomPoolIndex]; const enemyType = enemyTypes[randomTypeKey]; const enemyY = Math.random() * (gameHeight - enemyType.height); enemies.push(new Enemy(enemyY, randomTypeKey)); } } if (timestamp - lastPlanetSpawn > PLANET_SPAWN_RATE) { lastPlanetSpawn = timestamp; const radius = Math.random() * 50 + 40; const y = Math.random() * (gameHeight - radius * 2) + radius; const color = `hsl(${Math.random() * 60 + 180}, 50%, ${Math.random() * 30 + 40}%)`; const speed = PLANET_SPEED * (Math.random() * 0.5 + 0.75); terrain.push(new Planet(y, radius, color, speed)); } }
            if(player) player.update(); projectiles.forEach(p => p.update()); enemyProjectiles.forEach(p => p.update()); missiles.forEach(m => m.update()); enemies.forEach(e => e.update(timestamp)); powerUpItemsList.forEach(p => p.update()); stars.forEach(s => s.update()); terrain = terrain.filter(t => t.x > -t.radius * 2); terrain.forEach(t => t.update()); if (boss) boss.update(timestamp);
            checkCollisions();
            ctx.clearRect(0, 0, gameWidth, gameHeight); ctx.fillStyle = '#111'; ctx.fillRect(0, 0, gameWidth, gameHeight); stars.forEach(s => s.draw(ctx)); terrain.forEach(t => t.draw(ctx)); if(player) player.draw(ctx); options.forEach(o => o.draw(ctx)); projectiles.forEach(p => p.draw(ctx)); enemyProjectiles.forEach(p => p.draw(ctx)); missiles.forEach(m => m.draw(ctx)); enemies.forEach(e => e.draw(ctx)); powerUpItemsList.forEach(p => p.draw(ctx, timestamp)); if (boss) boss.draw(ctx);
            if (laserActive && player) { ctx.font = `bold ${LASER_FONT_SIZE}px sans-serif`; ctx.fillStyle = '#00aaff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; const textMetrics = ctx.measureText(LASER_TEXT); const laserWidth = textMetrics.width; const laserHeight = LASER_FONT_SIZE; const laserStartX = player.x + player.width; const laserStartY = player.y + player.height / 2; ctx.fillText(LASER_TEXT, laserStartX, laserStartY); const laserRect = { x: laserStartX, y: laserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(laserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(laserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(laserRect)) { /* 衝突処理 */ } }); options.forEach(option => { const optionLaserStartX = option.x + option.width; const optionLaserStartY = option.y + option.height / 2; ctx.fillText(LASER_TEXT, optionLaserStartX, optionLaserStartY); const optionLaserRect = { x: optionLaserStartX, y: optionLaserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(optionLaserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(optionLaserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(optionLaserRect)) { /* 衝突処理 */ } }); }); }
            updatePowerUpUI();
            requestAnimationFrame(gameLoop);
        }

        // --- ゲーム開始 ---
        init();

    </script>
</body>
</html>
