<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒªãƒ•ãƒ¬ã‚¯ã“VSå­¦ç¿’ã—ãªã„çµ„ç¹” (v10 - ãƒœã‚¹æ¡ä»¶ãƒ»å¹…å¤‰æ›´)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #222; margin: 0; font-family: 'Press Start 2P', cursive; color: #fff; flex-direction: column; }
        #gameContainer {
            position: relative;
            width: 960px; /* â˜… æ¨ªå¹…ã‚’960pxã«å¤‰æ›´ */
            height: 600px;
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden;
            margin-bottom: 10px;
        }
        canvas { display: block; background-color: #111; image-rendering: pixelated; }
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: 5px;
            border: 2px solid #fff;
            border-radius: 5px;
            width: 956px; /* â˜… ã‚³ãƒ³ãƒ†ãƒŠå¹…ã«åˆã‚ã›ã¦èª¿æ•´ (960 - 4) */
            box-sizing: border-box;
        }
        .powerUpItem { padding: 5px 10px; margin: 0 5px; border: 1px solid #555; color: #888; font-size: 12px; cursor: default; transition: all 0.2s ease; text-align: center; min-width: 60px; }
        .powerUpItem.highlighted { background-color: #ffcc00; color: #000; border-color: #fff; box-shadow: 0 0 10px #ffcc00; }
        .powerUpItem.active { background-color: #ff6600; color: #fff; border-color: #fff; }
        #uiLayer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 16px; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        #bossHpBar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 300px; height: 15px; border: 2px solid #fff; background-color: #555; display: none; z-index: 5; }
        #bossHpFill { width: 100%; height: 100%; background-color: #ff4444; transition: width 0.2s ease-out; }
        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 30px; border: 2px solid white; border-radius: 10px; font-size: 24px; text-align: center; display: none; z-index: 10; }
        #messageBox button { font-family: 'Press Start 2P', cursive; font-size: 16px; padding: 10px 20px; margin-top: 20px; cursor: pointer; background-color: #ffcc00; border: 2px solid #fff; color: #000; border-radius: 5px; transition: background-color 0.3s; }
        #messageBox button:hover { background-color: #ffa500; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: ğŸ’–ğŸ’–ğŸ’–</div>
        </div>
         <div id="bossHpBar"> <div id="bossHpFill"></div>
         </div>
         <div id="messageBox">
            <div id="messageText"></div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="speed">SPEED UP</div>
        <div class="powerUpItem" id="missile">MISSILE</div>
        <div class="powerUpItem" id="double">DOUBLE</div>
        <div class="powerUpItem" id="laser">LASER</div>
        <div class="powerUpItem" id="option">OPTION</div>
        <div class="powerUpItem" id="shield">? (SHIELD)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const bossHpBar = document.getElementById('bossHpBar');
        const bossHpFill = document.getElementById('bossHpFill');

        let gameWidth, gameHeight;
        let stars = [];

        // --- ç”»åƒèª­ã¿è¾¼ã¿ (å¤‰æ›´ãªã—) ---
        const playerImage = new Image(); playerImage.src = 'refleko_right.png';
        let playerImageLoaded = false; playerImage.onload = () => { playerImageLoaded = true; console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); }; playerImage.onerror = () => { console.error("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); };
        const optionImage = new Image(); optionImage.src = 'reflect_logo_3.png';
        let optionImageLoaded = false; optionImage.onload = () => { optionImageLoaded = true; console.log("ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); }; optionImage.onerror = () => { console.error("ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); };
        const bossImage = new Image(); bossImage.src = 'bigwork.png';
        let bossImageLoaded = false;
        bossImage.onload = () => { bossImageLoaded = true; console.log("ãƒœã‚¹ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); };
        bossImage.onerror = () => { console.error("ãƒœã‚¹ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); };


        // --- éŸ³å£°è¨­å®š (å¤‰æ›´ãªã—) ---
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
        const bombSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.4, attackCurve: 'exponential' } }).toDestination();

        function playSound(type) { /* ...å¤‰æ›´ãªã—... */
             if (!Tone.context.state || Tone.context.state !== 'running') { console.log("AudioContext is not running. Trying to resume..."); Tone.start().catch(e => console.error("Tone.start failed:", e)); }
            try { switch (type) { case 'shoot': synth.triggerAttackRelease("C5", "16n"); break; case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break; case 'playerHit': metalSynth.triggerAttackRelease("16n"); break; case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break; case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break; case 'gameOver': synth.triggerAttackRelease("C3", "4n", Tone.now()); synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4); synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6); break; case 'missile': const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); missileNoise.triggerAttackRelease("8n"); break; case 'laser': synth.triggerAttackRelease("A5", "64n"); break; case 'enemyShoot': bombSynth.triggerAttackRelease("C2", "8n"); break; case 'bossHit': metalSynth.triggerAttackRelease("8n", 0.5); break; case 'bossDefeat': synth.triggerAttackRelease("C6", "2n", Tone.now()); synth.triggerAttackRelease("G5", "2n", Tone.now()+0.1); synth.triggerAttackRelease("E5", "2n", Tone.now()+0.2); synth.triggerAttackRelease("C5", "1n", Tone.now()+0.3); break; } } catch (error) { console.error("Error playing sound:", error); }
        }

        // --- ã‚²ãƒ¼ãƒ è¨­å®š (â˜… BOSS_TRIGGER_SCORE å¤‰æ›´) ---
        let PLAYER_WIDTH = 40; let PLAYER_HEIGHT = 40; const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7; const PROJECTILE_FONT_SIZE = 20;
        const ENEMY_SPEED_BASE = 2; const ENEMY_SPAWN_RATE = 1000; const ENEMY_FONT_SIZE = 18;
        const ENEMY_PROJECTILE_SPEED = 3; const ENEMY_PROJECTILE_FONT_SIZE = 18;
        const POWERUP_ITEM_SPEED = 1.5; const POWERUP_ITEM_WIDTH = 12; const POWERUP_ITEM_HEIGHT = 20;
        const MISSILE_SPEED = 4; const MISSILE_FONT_SIZE = 20;
        const OPTION_WIDTH = 38; const OPTION_HEIGHT = 38; const OPTION_DISTANCE = 68;
        const STAR_COUNT = 100; const STAR_SPEED_FACTOR = 0.5;
        const PLANET_SPAWN_RATE = 8000; const PLANET_SPEED = 0.5;
        const LASER_TEXT = "çµŒé¨“å­¦ç¿’-".repeat(7); const LASER_FONT_SIZE = 14;
        const BOSS_TRIGGER_SCORE = 15000; // â˜… ãƒœã‚¹å‡ºç¾ã‚¹ã‚³ã‚¢ã‚’15000ã«å¤‰æ›´
        const BOSS_WIDTH = 200; const BOSS_HEIGHT = 200; const BOSS_MAX_HEALTH = 150;
        const BOSS_SHOOT_COOLDOWN = 1500; const BOSS_SCORE = 5000;

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ (å¤‰æ›´ãªã—) ---
        let player; let projectiles = []; let enemyProjectiles = []; let missiles = []; let enemies = []; let powerUpItemsList = []; let options = []; let terrain = [];
        let score = 0; let lives = 3; let gameOver = false; let gameWon = false;
        let gameRunning = false;
        let lastEnemySpawn = 0; let lastPlanetSpawn = 0;
        let keys = {}; let currentPowerUpIndex = -1;
        let activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
        let shieldHp = 0; let laserActive = false;
        let enemySpawnPool = [];
        let bossModeActive = false;
        let boss = null;

        const powerUpTypes = ['speed', 'missile', 'double', 'laser', 'option', 'shield'];

        // --- æ•µã®ç¨®é¡å®šç¾© (å¤‰æ›´ãªã—) ---
        const enemyTypes = { /* ...å¤‰æ›´ãªã—... */
            shortage: { text: "äººæ‰‹ä¸è¶³", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffdddd', health: 2, speedMultiplier: 0.9, value: 120, moveType: 'straight', dropChance: 0.15 * 1.5 },
            powerH:   { text: "ãƒ‘ãƒ¯ãƒãƒ©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffaaaa', health: 1, speedMultiplier: 1.2, value: 150, moveType: 'sine', dropChance: 0.2 * 1.5 },
            overtime: { text: "æ®‹æ¥­",   width: ENEMY_FONT_SIZE * 2, height: ENEMY_FONT_SIZE * 1.2, color: '#ddddff', health: 3, speedMultiplier: 0.7, value: 100, moveType: 'straight', dropChance: 0.1 * 1.5 },
            sexualH:  { text: "ã‚»ã‚¯ãƒãƒ©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffccff', health: 1, speedMultiplier: 1.1, value: 140, moveType: 'sine', dropChance: 0.18 * 1.5 },
            turnover: { text: "é«˜é›¢è·ç‡", width: ENEMY_FONT_SIZE * 5, height: ENEMY_FONT_SIZE * 1.2, color: '#ffffcc', health: 2, speedMultiplier: 1.0, value: 130, moveType: 'straight', dropChance: 0.22 * 1.5 },
            nonLearningOrg: { text: "å­¦ç¿’ã—ãªã„çµ„ç¹”", width: ENEMY_FONT_SIZE * 7, height: ENEMY_FONT_SIZE * 1.2, color: '#aaaaaa', health: 5, speedMultiplier: 0.6, value: 300, moveType: 'straight', dropChance: 0.15 * 1.5 },
            resistance: { text: "æŠµæŠ—å‹¢åŠ›", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#cc5555', health: 2, speedMultiplier: 0.5, value: 180, moveType: 'shooter', dropChance: 0.2 * 1.5, shootCooldown: 2500 }
        };

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Player { /* ...å¤‰æ›´ãªã—... */
             constructor(x, y) { this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT; this.speed = PLAYER_SPEED_BASE; this.shootCooldown = 0; this.missileCooldown = 0; this.laserDuration = 0; this.invincible = false; this.invincibleTimer = 0; }
            draw(ctx) { let drawPlayer = true; if (this.invincible) { drawPlayer = Math.floor(this.invincibleTimer / 100) % 2 === 0; } if (drawPlayer) { if (playerImageLoaded) { ctx.drawImage(playerImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10); ctx.fillStyle = '#000000'; ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10); } } if (activePowerUps.shield && shieldHp > 0) { ctx.save(); ctx.globalAlpha = 0.5 + shieldHp * 0.25; ctx.strokeStyle = `rgba(0, 150, 255, 1)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1; } }
            update() { if (this.invincible) { this.invincibleTimer -= 1000/60; if (this.invincibleTimer <= 0) { this.invincible = false; } } if (keys['ArrowUp'] || keys['w']) this.y -= this.speed; if (keys['ArrowDown'] || keys['s']) this.y += this.speed; if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed; if (keys['ArrowRight'] || keys['d']) this.x += this.speed; this.x = Math.max(0, Math.min(this.x, gameWidth - this.width)); this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); if (this.shootCooldown > 0) this.shootCooldown -= 16.67; if (this.missileCooldown > 0) this.missileCooldown -= 16.67; if (this.laserDuration > 0) this.laserDuration -= 16.67; else laserActive = false; if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) { this.shoot(); } if (activePowerUps.missile && this.missileCooldown <= 0) { this.fireMissile(); this.missileCooldown = 800; } options.forEach((option, index) => { option.update(this.x, this.y, index); }); }
             shoot() { if (gameOver || gameWon) return; this.shootCooldown = activePowerUps.laser ? 50 : 200; const projectileY = this.y + this.height / 2; if (activePowerUps.laser) { laserActive = true; this.laserDuration = 150; playSound('laser'); } else { projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', 0, 'ğŸ’¬', PROJECTILE_FONT_SIZE)); playSound('shoot'); if (activePowerUps.double) { projectiles.push(new Projectile(this.x + this.width, projectileY - 10, 'player', Math.PI / 18, 'ğŸ’¬', PROJECTILE_FONT_SIZE)); projectiles.push(new Projectile(this.x + this.width, projectileY + 10, 'player', -Math.PI / 18, 'ğŸ’¬', PROJECTILE_FONT_SIZE)); } } options.forEach(option => option.shoot(activePowerUps.laser)); }
            fireMissile() { if (gameOver || gameWon) return; missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down')); missiles.push(new Missile(this.x + this.width / 2, this.y, 'up')); playSound('missile'); }
            activatePowerUp() { if (currentPowerUpIndex !== -1) { const selectedPowerUp = powerUpTypes[currentPowerUpIndex]; playSound('powerupActivate'); switch (selectedPowerUp) { case 'speed': activePowerUps.speed++; this.speed = PLAYER_SPEED_BASE + activePowerUps.speed * 1; break; case 'missile': activePowerUps.missile = true; break; case 'double': activePowerUps.double = true; activePowerUps.laser = false; break; case 'laser': activePowerUps.laser = true; activePowerUps.double = false; break; case 'option': if (activePowerUps.option < 2) { activePowerUps.option++; options.push(new Option()); } break; case 'shield': activePowerUps.shield = true; shieldHp = 2; break; } updatePowerUpUI(); currentPowerUpIndex = -1; highlightPowerUp(); } }
            hit() { if (this.invincible || gameWon) return; playSound('playerHit'); if (activePowerUps.shield && shieldHp > 0) { shieldHp--; this.setInvincible(500); if (shieldHp <= 0) { activePowerUps.shield = false; const shieldElement = document.getElementById('shield'); if (shieldElement) shieldElement.classList.remove('active'); } return; } lives--; updateLivesDisplay(); resetPowerUps(); if (lives <= 0) { gameOver = true; playSound('gameOver'); showGameOverMessage(); } else { this.x = 50; this.y = gameHeight / 2 - PLAYER_HEIGHT / 2; this.setInvincible(2000); } }
            setInvincible(duration) { this.invincible = true; this.invincibleTimer = duration; }
        }

        // --- å¼¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Projectile { /* ...å¤‰æ›´ãªã—... */
             constructor(x, y, type, angle = 0, text = '?', fontSize = 16, speed = PROJECTILE_SPEED) { this.x = x; this.y = y; this.fontSize = fontSize; this.width = this.fontSize; this.height = this.fontSize; this.speed = speed; this.type = type; this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.text = text; }
            draw(ctx) { ctx.font = `${this.fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.type === 'player' ? '#ffffff' : '#ff5555'; ctx.fillText(this.text, this.x, this.y); }
            update() { this.x += this.vx; this.y += this.vy; }
        }

        // --- ãƒŸã‚µã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Missile { /* ...å¤‰æ›´ãªã—... */
            constructor(x, y, direction) { this.x = x; this.y = y; this.fontSize = MISSILE_FONT_SIZE; this.width = this.fontSize; this.height = this.fontSize; this.speed = MISSILE_SPEED; this.direction = direction; }
            draw(ctx) { ctx.font = `bold ${this.fontSize}px "Press Start 2P"`; ctx.fillStyle = '#ff0000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ï¼Ÿ', this.x, this.y); }
            update() { if (this.direction === 'down') { this.y += this.speed; if (this.y > gameHeight - this.height / 2 - 5) { this.y = gameHeight - this.height / 2 - 5; this.x += this.speed / 2; this.direction = 'ground'; } } else { this.y -= this.speed; if (this.y < this.height / 2 + 5) { this.y = this.height / 2 + 5; this.x += this.speed / 2; this.direction = 'ceiling'; } } if (this.direction === 'ground' || this.direction === 'ceiling') { this.x += this.speed / 1.5; } }
        }


        // --- æ•µã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Enemy { /* ...å¤‰æ›´ãªã—... */
             constructor(y, typeName) { const type = enemyTypes[typeName] || enemyTypes.shortage; this.typeName = typeName; this.text = type.text; this.width = type.width; this.height = type.height; this.x = gameWidth; this.y = y; this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; this.color = type.color; this.health = type.health; this.value = type.value; this.moveType = type.moveType; this.amplitude = Math.random() * 40 + 10; this.frequency = Math.random() * 0.04 + 0.01; this.initialY = y; this.canDropPowerUp = Math.random() < type.dropChance; if (this.moveType === 'shooter') { this.shootCooldown = type.shootCooldown + (Math.random() * 500 - 250); this.lastShotTime = 0; } }
            draw(ctx) { ctx.font = `bold ${ENEMY_FONT_SIZE}px "Press Start 2P"`; ctx.fillStyle = this.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(this.text, this.x, this.y); }
            update(timestamp) { this.x -= this.speed; if (this.moveType === 'sine') { this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); } else if (this.moveType === 'shooter' && player) { if (this.x < gameWidth * 0.9 && this.x > 0 && timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; this.shootCooldown = enemyTypes[this.typeName].shootCooldown + (Math.random() * 500 - 250); } } }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const targetX = player.x + player.width / 2; const targetY = player.y + player.height / 2; const dx = targetX - (this.x); const dy = targetY - (this.y + this.height / 2); const angle = Math.atan2(dy, dx); enemyProjectiles.push(new Projectile( this.x, this.y + this.height / 2, 'enemy', angle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED )); }
            hit() { this.health--; if (this.health <= 0) { addScore(this.value); playSound('enemyHit'); if (this.canDropPowerUp) { dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); } return true; } const originalColor = this.color; this.color = '#ffffff'; setTimeout(() => { this.color = originalColor; }, 60); return false; }
        }

        // --- PowerUpItemã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class PowerUpItem { /* ...å¤‰æ›´ãªã—... */
            constructor(x, y) { this.x = x - POWERUP_ITEM_WIDTH / 2; this.y = y - POWERUP_ITEM_HEIGHT / 2; this.width = POWERUP_ITEM_WIDTH; this.height = POWERUP_ITEM_HEIGHT; this.speed = POWERUP_ITEM_SPEED; this.colorTop = '#aaaaee'; this.colorBody = '#4444ff'; this.colorAccent = '#ff4444'; this.sparkleOffset = 0; this.sparkleSpeed = 0.1; }
            draw(ctx, timestamp) { const topHeight = this.height * 0.2; const bodyHeight = this.height * 0.6; const bottomHeight = this.height * 0.2; ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y, this.width, topHeight); ctx.fillStyle = this.colorBody; ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight); ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight); ctx.fillStyle = this.colorAccent; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2); ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("RB", this.x + this.width / 2, this.y + this.height / 2 + 1); ctx.fillStyle = '#ffffaa'; const sparkleSize = 2; const sparkleDistance = Math.max(this.width, this.height) * 0.7; const angle1 = timestamp * 0.005 + this.sparkleOffset; const angle2 = timestamp * 0.005 + Math.PI / 2 + this.sparkleOffset; const angle3 = timestamp * 0.005 + Math.PI + this.sparkleOffset; const angle4 = timestamp * 0.005 + Math.PI * 1.5 + this.sparkleOffset; const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2; ctx.fillRect(centerX + Math.cos(angle1) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle1) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle2) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle2) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle3) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle3) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle4) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle4) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); }
            update() { this.x -= this.speed; }
        }

        // --- Optionã‚¯ãƒ©ã‚¹ (â˜… å®šæ•°å¤‰æ›´é©ç”¨) ---
        class Option {
            constructor() {
                this.x = 0; this.y = 0;
                this.width = OPTION_WIDTH; // â˜… å®šæ•°ä½¿ç”¨
                this.height = OPTION_HEIGHT; // â˜… å®šæ•°ä½¿ç”¨
                this.size = Math.max(this.width, this.height);
                this.followDelay = 10; this.history = []; this.shootCooldown = 0;
            }
            draw(ctx) { /* ...æç”»ãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ãªã—... */ if (optionImageLoaded) { ctx.drawImage(optionImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } }
            update(playerX, playerY, index) { /* ...è¿½å¾“ãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ãªã— (OPTION_DISTANCEä½¿ç”¨)... */ this.history.push({ x: playerX, y: playerY }); if (this.history.length > this.followDelay * (index + 1)) { this.history.shift(); } if (this.history.length > 0) { const targetPos = this.history[0]; this.x = targetPos.x; this.y = targetPos.y; } else { this.x = playerX - OPTION_DISTANCE * (index + 1); this.y = playerY; } this.x = Math.max(0, Math.min(this.x, gameWidth - this.width)); this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); if (this.shootCooldown > 0) this.shootCooldown -= 16.67; }
             shoot(isLaser) { /* ...å°„æ’ƒãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ãªã—... */ if (this.shootCooldown <= 0) { this.shootCooldown = 200; const projectileY = this.y + this.height / 2; const projectileX = this.x + this.width; if (isLaser) { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '?', PROJECTILE_FONT_SIZE)); playSound('laser'); } else { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, 'ğŸ’¬', PROJECTILE_FONT_SIZE)); playSound('shoot'); } } }
        }

        // --- Starã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Star { /* ...å¤‰æ›´ãªã—... */
            constructor() { this.x = Math.random() * gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; }
            draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
            update() { this.x -= this.speed; if (this.x < 0) { this.x = gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; } }
        }

        // --- åœ°å½¢ï¼ˆæƒ‘æ˜Ÿï¼‰ã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Planet { /* ...å¤‰æ›´ãªã—... */
            constructor(y, radius, color, speed) { this.x = gameWidth + radius; this.y = y; this.radius = radius; this.color = color; this.speed = speed; }
            draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; const numCraters = Math.floor(this.radius / 10); for (let i = 0; i < numCraters; i++) { const craterRadius = Math.random() * (this.radius * 0.15) + (this.radius * 0.05); const angle = Math.random() * Math.PI * 2; const dist = Math.random() * (this.radius - craterRadius); const craterX = this.x + Math.cos(angle) * dist; const craterY = this.y + Math.sin(angle) * dist; ctx.beginPath(); ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2); ctx.fill(); } }
            update() { this.x -= this.speed; }
            checkCollisionWithRect(rect) { const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width)); const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height)); const distanceX = this.x - closestX; const distanceY = this.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
            checkCollisionWithPoint(point) { const distanceX = this.x - point.x; const distanceY = this.y - point.y; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
        }

        // --- â˜… ãƒœã‚¹ã‚¯ãƒ©ã‚¹ ---
        class Boss {
            constructor() {
                this.width = BOSS_WIDTH;
                this.height = BOSS_HEIGHT;
                this.x = gameWidth; // ç”»é¢å³å¤–ã‹ã‚‰
                this.y = gameHeight / 2 - this.height / 2; // ä¸­å¤®ã®é«˜ã•
                this.speedX = 1.5; // ç™»å ´æ™‚ã®æ¨ªç§»å‹•é€Ÿåº¦
                this.speedY = 1;   // ç™»å ´å¾Œã®ç¸¦ç§»å‹•é€Ÿåº¦
                this.maxHealth = BOSS_MAX_HEALTH;
                this.health = this.maxHealth;
                this.shootCooldown = BOSS_SHOOT_COOLDOWN;
                this.lastShotTime = 0;
                this.onScreen = false; // ç”»é¢å†…ã«å®Œå…¨ã«ç™»å ´ã—ãŸã‹
                this.targetY = this.y; // ç¸¦ç§»å‹•ã®ç›®æ¨™Yåº§æ¨™
                this.hitFlashTimer = 0; // è¢«å¼¾æ™‚ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¿ã‚¤ãƒãƒ¼
            }

            draw(ctx) {
                let currentImage = bossImage;
                // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                if (this.hitFlashTimer > 0) {
                    if (Math.floor(this.hitFlashTimer / 50) % 2 === 0) {
                       ctx.globalAlpha = 0.5;
                    }
                }

                if (bossImageLoaded) {
                    ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
                } else {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    ctx.fillStyle = '#880000'; // æš—ã„èµ¤
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                ctx.globalAlpha = 1.0; // é€æ˜åº¦ã‚’æˆ»ã™

                // HPãƒãƒ¼æ›´æ–° (ãƒœã‚¹å‡ºç¾ä¸­ã®ã¿è¡¨ç¤º)
                bossHpBar.style.display = 'block';
                const hpPercentage = Math.max(0, this.health / this.maxHealth) * 100;
                bossHpFill.style.width = `${hpPercentage}%`;
            }

            update(timestamp) {
                // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¿ã‚¤ãƒãƒ¼æ¸›å°‘
                if (this.hitFlashTimer > 0) {
                    this.hitFlashTimer -= 1000 / 60; // 1ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“(ms)
                }


                if (!this.onScreen) {
                    // ç”»é¢å†…ã«ç§»å‹•
                    this.x -= this.speedX;
                    if (this.x <= gameWidth - this.width - 50) { // ç”»é¢å³ç«¯ã‹ã‚‰å°‘ã—å†…å´ã¸
                        this.x = gameWidth - this.width - 50;
                        this.onScreen = true;
                        this.lastShotTime = timestamp; // ç”»é¢ã«å‡ºã¦ã‹ã‚‰å°„æ’ƒé–‹å§‹
                    }
                } else {
                    // ç”»é¢å†…ã§ã®ä¸Šä¸‹ç§»å‹•
                    this.y += this.speedY;
                    if (this.y <= 0 || this.y + this.height >= gameHeight) {
                        this.speedY *= -1; // ç«¯ã«å½“ãŸã£ãŸã‚‰åè»¢
                        this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); // ç”»é¢å†…ã«åã‚ã‚‹
                    }

                    // å°„æ’ƒ
                    if (timestamp - this.lastShotTime > this.shootCooldown) {
                        this.shoot();
                        this.lastShotTime = timestamp;
                    }
                }
            }

            shoot() {
                if (!player || gameOver || gameWon) return;
                playSound('enemyShoot'); // æ•µã¨åŒã˜å°„æ’ƒéŸ³ã‚’ä½¿ç”¨
                const shootX = this.x; // ãƒœã‚¹ã®å·¦ç«¯ã‹ã‚‰
                const shootY = this.y + this.height / 2; // ãƒœã‚¹ã®ä¸­å¿ƒé«˜ã•ã‹ã‚‰

                const angleToPlayer = Math.atan2(player.y + player.height / 2 - shootY, player.x + player.width / 2 - shootX);
                const spreadAngle = Math.PI / 9; // æ”¾å°„çŠ¶ã®è§’åº¦ (3ç™ºã§60åº¦ãã‚‰ã„)

                // 3æ–¹å‘ã«ç™ºå°„
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer - spreadAngle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer + spreadAngle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
            }

            hit() {
                if (this.health <= 0) return false; // ã™ã§ã«å€’ã•ã‚Œã¦ã„ã‚‹

                this.health--;
                playSound('bossHit');
                this.hitFlashTimer = 150; // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ™‚é–“(ms)

                if (this.health <= 0) {
                    addScore(BOSS_SCORE);
                    playSound('bossDefeat');
                    bossHpBar.style.display = 'none'; // HPãƒãƒ¼ã‚’éš ã™
                    gameWon = true; // â˜… ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢
                    showGameWonMessage();
                    // â˜… çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã©ã‚’ã“ã“ã«è¿½åŠ å¯èƒ½
                    return true; // å€’ã•ã‚ŒãŸ
                }
                return false; // ã¾ã ç”Ÿå­˜
            }
        }


        // --- åˆæœŸåŒ– (â˜… ãƒœã‚¹é–¢é€£ãƒªã‚»ãƒƒãƒˆè¿½åŠ ) ---
        function init() {
            resizeCanvas(); player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2);
            projectiles = []; enemyProjectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = []; terrain = [];
            score = 0; lives = 3; gameOver = false; gameWon = false; // â˜… gameWonãƒªã‚»ãƒƒãƒˆ
            gameRunning = false; lastEnemySpawn = 0; lastPlanetSpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            bossModeActive = false; // â˜… bossModeãƒªã‚»ãƒƒãƒˆ
            boss = null; // â˜… bossãƒªã‚»ãƒƒãƒˆ
            bossHpBar.style.display = 'none'; // â˜… HPãƒãƒ¼éè¡¨ç¤º

            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none'; stars = []; for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            enemySpawnPool = []; Object.keys(enemyTypes).forEach(key => { const weight = (key === 'resistance') ? 1 : 2; for (let i = 0; i < weight; i++) { enemySpawnPool.push(key); } });
            showStartMessage(); const newRestartButton = restartButton.cloneNode(true); restartButton.parentNode.replaceChild(newRestartButton, restartButton); document.getElementById('restartButton').addEventListener('click', startGame);
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.removeEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); window.addEventListener('resize', resizeCanvas);
        }

        // --- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºé–¢æ•° (ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ ) ---
        function showStartMessage() { /* ...å¤‰æ›´ãªã—... */ messageText.innerHTML = "ãƒªãƒ•ãƒ¬ã‚¯ã“VSå­¦ç¿’ã—ãªã„çµ„ç¹”<br>Arrow Keys/WASD: Move<br>Space/Z: Shoot<br>Shift/X: Activate PowerUp<br><br>PRESS START BUTTON"; const startButton = document.getElementById('restartButton'); startButton.textContent = "START GAME"; messageBox.style.display = 'block'; gameRunning = false; }
        function showGameOverMessage() { /* ...å¤‰æ›´ãªã—... */ messageText.innerHTML = `GAME OVER<br>FINAL SCORE: ${score}`; const restartBtn = document.getElementById('restartButton'); restartBtn.textContent = "RESTART"; messageBox.style.display = 'block'; gameRunning = false; }
        function showGameWonMessage() { // â˜… ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            messageText.innerHTML = `CONGRATULATIONS!<br>YOU WIN!<br>FINAL SCORE: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "PLAY AGAIN?";
            messageBox.style.display = 'block';
            gameRunning = false; // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—åœæ­¢
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•° (å¤‰æ›´ãªã—) ---
        function startGame() { /* ...å¤‰æ›´ãªã—... */ if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); } messageBox.style.display = 'none'; if (gameOver || gameWon) { init(); } gameOver = false; gameWon = false; gameRunning = true; requestAnimationFrame(gameLoop); }

        // --- ãƒªã‚µã‚¤ã‚ºå‡¦ç† (â˜… ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒãƒ¼ã®å¹…èª¿æ•´ã‚‚ã“ã“ã§è¡Œã†) ---
        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth;
            gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;
            stars.forEach(star => { star.x = Math.min(star.x, gameWidth); star.y = Math.min(star.y, gameHeight); });
            // â˜… ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒãƒ¼ã®å¹…ã‚‚å‹•çš„ã«èª¿æ•´
            powerUpBar.style.width = `${gameWidth - 4}px`;
        }

        // --- ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—å‡¦ç† (å¤‰æ›´ãªã—) ---
        function collectPowerUp() { /* ...å¤‰æ›´ãªã—... */ playSound('powerupCollect'); currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; highlightPowerUp(); }
        function highlightPowerUp() { /* ...å¤‰æ›´ãªã—... */ powerUpItems.forEach((item, index) => { item.classList.toggle('highlighted', index === currentPowerUpIndex); }); }
        function updatePowerUpUI() { /* ...å¤‰æ›´ãªã—... */ powerUpTypes.forEach((type, index) => { const element = document.getElementById(type); if (element) { let isActive = false; let text = element.textContent.split(' (')[0]; switch(type) { case 'speed': isActive = activePowerUps.speed > 0; if (isActive) text += ` (${activePowerUps.speed})`; break; case 'option': isActive = activePowerUps.option > 0; if (isActive) text += ` (${activePowerUps.option})`; break; case 'shield': isActive = activePowerUps.shield; text = isActive ? `SHIELD (${shieldHp})` : '? (SHIELD)'; break; default: isActive = activePowerUps[type]; break; } element.classList.toggle('active', isActive); element.textContent = text; } }); }
        function resetPowerUps(updateUI = true) { /* ...å¤‰æ›´ãªã—... */ activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false }; if (player) player.speed = PLAYER_SPEED_BASE; options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1; if(updateUI) { updatePowerUpUI(); highlightPowerUp(); } }
        function dropPowerUpItem(x, y) { /* ...å¤‰æ›´ãªã—... */ powerUpItemsList.push(new PowerUpItem(x, y)); }

        // --- ã‚¹ã‚³ã‚¢ãƒ»ãƒ©ã‚¤ãƒ•æ›´æ–° (â˜… ãƒœã‚¹ãƒ¢ãƒ¼ãƒ‰ãƒˆãƒªã‚¬ãƒ¼è¿½åŠ ) ---
        function addScore(amount) {
            if (gameOver || gameWon) return; // ã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã¯ã‚¹ã‚³ã‚¢åŠ ç®—ã—ãªã„
            score += amount;
            updateScoreDisplay();

            // â˜… ãƒœã‚¹ãƒ¢ãƒ¼ãƒ‰ãƒˆãƒªã‚¬ãƒ¼
            if (!bossModeActive && score >= BOSS_TRIGGER_SCORE) {
                bossModeActive = true;
                // æ—¢å­˜ã®æ•µãƒ»åœ°å½¢ãƒ»æ•µå¼¾ã‚’ã‚¯ãƒªã‚¢
                enemies = [];
                terrain = [];
                enemyProjectiles = [];
                powerUpItemsList = []; // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚‚æ¶ˆã™
                // ãƒœã‚¹ç”Ÿæˆ
                boss = new Boss();
                console.log("BOSS MODE ACTIVATED!");
                // TODO: "WARNING"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãªã©ï¼Ÿ
            }
        }
        function updateScoreDisplay() { /* ...å¤‰æ›´ãªã—... */ scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { /* ...å¤‰æ›´ãªã—... */ livesDisplay.innerHTML = `LIVES: ${'ğŸ’–'.repeat(lives)}`; }

        // --- è¡çªåˆ¤å®š (â˜… ãƒœã‚¹é–¢é€£è¿½åŠ ) ---
        function checkCollisions() {
            if (!player) return; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã¯åˆ¤å®šã—ãªã„

            // åœ°å½¢ã¨ã®è¡çªåˆ¤å®š
            terrain.forEach(planet => {
                if (!player.invincible && planet.checkCollisionWithRect(player)) { player.hit(); }
                projectiles = projectiles.filter(proj => !(proj.type === 'player' && planet.checkCollisionWithPoint(proj)));
                enemyProjectiles = enemyProjectiles.filter(proj => !planet.checkCollisionWithPoint(proj));
                missiles = missiles.filter(missile => !planet.checkCollisionWithPoint({ x: missile.x, y: missile.direction === 'down' ? missile.y + missile.height : missile.y - missile.height }));
            });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ vs æ•µ/ãƒœã‚¹
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                // é€šå¸¸æ•µ
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(projHitbox, enemy)) {
                        if (enemy.hit()) { enemies.splice(i, 1); }
                        return false; // å¼¾æ¶ˆæ»…
                    }
                }
                // ãƒœã‚¹
                if (boss && boss.onScreen && isColliding(projHitbox, boss)) {
                     if (boss.hit()) { boss = null; } // ãƒœã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‰Šé™¤
                     return false; // å¼¾æ¶ˆæ»…
                }
                return proj.x < gameWidth + proj.width; // ç”»é¢å¤–åˆ¤å®š
            });

            // æ•µå¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            enemyProjectiles = enemyProjectiles.filter(proj => {
                 const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                 if (!player.invincible && isColliding(projHitbox, player)) {
                    player.hit();
                    return false;
                }
                return proj.x > -proj.width && proj.x < gameWidth + proj.width && proj.y > -proj.height && proj.y < gameHeight + proj.height;
            });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒŸã‚µã‚¤ãƒ« vs æ•µ/ãƒœã‚¹
             missiles = missiles.filter(missile => {
                 const missileHitbox = { x: missile.x - missile.width / 2, y: missile.y - missile.height / 2, width: missile.width, height: missile.height };
                 // é€šå¸¸æ•µ
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(missileHitbox, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                         return false;
                     }
                 }
                 // ãƒœã‚¹
                 if (boss && boss.onScreen && isColliding(missileHitbox, boss)) {
                     if (boss.hit()) { boss = null; }
                     return false;
                 }
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
             });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs æ•µ/ãƒœã‚¹
            if (!player.invincible) {
                // é€šå¸¸æ•µ
                enemies.forEach((enemy, index) => { if (isColliding(player, enemy)) { player.hit(); if (enemy.hit()) { enemies.splice(index, 1); } } });
                // ãƒœã‚¹
                if (boss && boss.onScreen && isColliding(player, boss)) {
                    player.hit(); // ãƒœã‚¹ã«æ¥è§¦ã—ã¦ã‚‚å³æ­»
                }
            }

             // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
             powerUpItemsList = powerUpItemsList.filter(item => { if (isColliding(player, item)) { collectPowerUp(); return false; } return item.x > -item.width; });

             // ãƒ¬ãƒ¼ã‚¶ãƒ¼ vs æ•µ/ãƒœã‚¹ (ãƒ¬ãƒ¼ã‚¶ãƒ¼æç”»æ™‚ã«åˆ¤å®š)
        }
        function isColliding(rect1, rect2) { /* ...å¤‰æ›´ãªã—... */ return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ› (å¤‰æ›´ãªã—) ---
        function handleKeyDown(e) { /* ...å¤‰æ›´ãªã—... */ if (!gameRunning && messageBox.style.display === 'block') { if (e.key === 'Shift' || e.key.toLowerCase() === 'x') { e.preventDefault(); return; } if (e.key === ' ' || e.key.toLowerCase() === 'z') { e.preventDefault(); return; } } else if (gameRunning) { keys[e.key] = true; if ((e.key === 'Shift' || e.key.toLowerCase() === 'x') && !e.repeat) { player.activatePowerUp(); } if (e.key === ' ' || e.key.toLowerCase() === 'z') { keys[e.key] = true; } } if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'x', 'w', 'a', 's', 'd'].includes(e.key)) { e.preventDefault(); } }
        function handleKeyUp(e) { /* ...å¤‰æ›´ãªã—... */ keys[e.key] = false; }

        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— (â˜… ãƒœã‚¹å‡¦ç†ã€ã‚¹ãƒãƒ¼ãƒ³åˆ¶å¾¡è¿½åŠ ) ---
        function gameLoop(timestamp) {
            if (gameOver || gameWon || !gameRunning) { // â˜… gameWonã§ã‚‚åœæ­¢
                return;
            }

            // ã‚¹ãƒãƒ¼ãƒ³å‡¦ç† (â˜… ãƒœã‚¹ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯åœæ­¢)
            if (!bossModeActive) {
                // æ•µ
                if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) { lastEnemySpawn = timestamp; if (enemySpawnPool.length > 0) { const randomPoolIndex = Math.floor(Math.random() * enemySpawnPool.length); const randomTypeKey = enemySpawnPool[randomPoolIndex]; const enemyType = enemyTypes[randomTypeKey]; const enemyY = Math.random() * (gameHeight - enemyType.height); enemies.push(new Enemy(enemyY, randomTypeKey)); } }
                // åœ°å½¢
                if (timestamp - lastPlanetSpawn > PLANET_SPAWN_RATE) { lastPlanetSpawn = timestamp; const radius = Math.random() * 50 + 40; const y = Math.random() * (gameHeight - radius * 2) + radius; const color = `hsl(${Math.random() * 60 + 180}, 50%, ${Math.random() * 30 + 40}%)`; const speed = PLANET_SPEED * (Math.random() * 0.5 + 0.75); terrain.push(new Planet(y, radius, color, speed)); }
            }

            // æ›´æ–°å‡¦ç†
            if(player) player.update();
            projectiles.forEach(p => p.update());
            enemyProjectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update(timestamp));
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());
            terrain = terrain.filter(t => t.x > -t.radius * 2); // ç”»é¢å·¦ç«¯ã§æ¶ˆã™
            terrain.forEach(t => t.update());
            options.forEach(o => o.update(player?.x ?? 0, player?.y ?? 0, options.indexOf(o)));
            if (boss) boss.update(timestamp); // â˜… ãƒœã‚¹ã®æ›´æ–°

            // è¡çªåˆ¤å®š
            checkCollisions();

            // æç”»å‡¦ç†
            ctx.clearRect(0, 0, gameWidth, gameHeight); ctx.fillStyle = '#111'; ctx.fillRect(0, 0, gameWidth, gameHeight);
            stars.forEach(s => s.draw(ctx));
            terrain.forEach(t => t.draw(ctx));

            if(player) player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            enemyProjectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            powerUpItemsList.forEach(p => p.draw(ctx, timestamp));
            if (boss) boss.draw(ctx); // â˜… ãƒœã‚¹ã®æç”»

            // ãƒ¬ãƒ¼ã‚¶ãƒ¼æç”»ã¨è¡çªåˆ¤å®š (â˜… ãƒœã‚¹ã¨ã®è¡çªåˆ¤å®šè¿½åŠ )
             if (laserActive && player) {
                 ctx.font = `bold ${LASER_FONT_SIZE}px sans-serif`; ctx.fillStyle = '#00aaff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                 const textMetrics = ctx.measureText(LASER_TEXT); const laserWidth = textMetrics.width; const laserHeight = LASER_FONT_SIZE;

                 // æœ¬ä½“ãƒ¬ãƒ¼ã‚¶ãƒ¼å‡¦ç†
                 const laserStartX = player.x + player.width; const laserStartY = player.y + player.height / 2; ctx.fillText(LASER_TEXT, laserStartX, laserStartY); const laserRect = { x: laserStartX, y: laserStartY - laserHeight / 2, width: laserWidth, height: laserHeight };
                 for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(laserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } }
                 if (boss && boss.onScreen && isColliding(laserRect, boss)) { if (boss.hit()) { boss = null; } } // â˜… vs ãƒœã‚¹
                 terrain.forEach(planet => { if (planet.checkCollisionWithRect(laserRect)) { /* è¡çªå‡¦ç† */ } });

                 // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ¬ãƒ¼ã‚¶ãƒ¼å‡¦ç†
                 options.forEach(option => { const optionLaserStartX = option.x + option.width; const optionLaserStartY = option.y + option.height / 2; ctx.fillText(LASER_TEXT, optionLaserStartX, optionLaserStartY); const optionLaserRect = { x: optionLaserStartX, y: optionLaserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(optionLaserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(optionLaserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(optionLaserRect)) { /* è¡çªå‡¦ç† */ } }); });
             }

            updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        init();

    </script>
</body>
</html>

