<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚µãƒ©ãƒªãƒ¼ãƒãƒ³ãƒ»ã‚°ãƒ©ãƒ‡ã‚£ã‚¦ã‚¹ (v2)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            flex-direction: column; /* ç¸¦æ–¹å‘ã«è¦ç´ ã‚’ä¸¦ã¹ã‚‹ */
        }
        #gameContainer {
            position: relative; /* ç›¸å¯¾ä½ç½®æŒ‡å®š */
            width: 800px; /* ã‚²ãƒ¼ãƒ ç”»é¢ã®å¹… */
            height: 600px; /* ã‚²ãƒ¼ãƒ ç”»é¢ã®é«˜ã• */
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden; /* ã¯ã¿å‡ºã—ãŸè¦ç´ ã‚’éš ã™ */
            margin-bottom: 10px; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒãƒ¼ã®é–“éš” */
        }
        canvas {
            display: block;
            background-color: #111; /* èƒŒæ™¯è‰²ã‚’å°‘ã—æ˜ã‚‹ã */
            image-rendering: pixelated; /* ãƒ‰ãƒƒãƒˆçµµæ„Ÿã‚’å‡ºã™ */
        }
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: 5px;
            border: 2px solid #fff;
            border-radius: 5px;
            width: 796px; /* ã‚³ãƒ³ãƒ†ãƒŠå¹…ã«åˆã‚ã›ã‚‹ */
            box-sizing: border-box; /* paddingã¨borderã‚’å¹…ã«å«ã‚ã‚‹ */
        }
        .powerUpItem {
            padding: 5px 10px;
            margin: 0 5px;
            border: 1px solid #555;
            color: #888;
            font-size: 12px;
            cursor: default; /* é€šå¸¸ã®ã‚«ãƒ¼ã‚½ãƒ« */
            transition: all 0.2s ease;
            text-align: center; /* ä¸­å¤®æƒãˆã‚’è¿½åŠ  */
            min-width: 60px; /* æœ€ä½å¹…ã‚’ç¢ºä¿ */
        }
        .powerUpItem.highlighted {
            background-color: #ffcc00;
            color: #000;
            border-color: #fff;
            box-shadow: 0 0 10px #ffcc00;
        }
        .powerUpItem.active {
            background-color: #ff6600; /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã®è‰² */
            color: #fff;
            border-color: #fff;
        }
        #uiLayer {
            position: absolute; /* çµ¶å¯¾ä½ç½®æŒ‡å®š */
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            pointer-events: none; /* UIè¦ç´ ãŒã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¦¨ã’ãªã„ã‚ˆã†ã« */
            text-shadow: 1px 1px 2px #000;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border: 2px solid white;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
            z-index: 10;
        }
         #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            background-color: #ffcc00;
            border: 2px solid #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #messageBox button:hover {
            background-color: #ffa500;
        }
        /* èƒŒæ™¯ã®æ˜Ÿ (CSSã§ã®å®Ÿè£…ã¯å‰Šé™¤ã—ã€Canvasã§æç”») */
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: ğŸ’–ğŸ’–ğŸ’–</div>
        </div>
         <div id="messageBox">
            <div id="messageText"></div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="speed">SPEED UP</div>
        <div class="powerUpItem" id="missile">MISSILE</div>
        <div class="powerUpItem" id="double">DOUBLE</div>
        <div class="powerUpItem" id="laser">LASER</div>
        <div class="powerUpItem" id="option">OPTION</div>
        <div class="powerUpItem" id="shield">? (SHIELD)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        let gameWidth, gameHeight; // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«å–å¾—
        let stars = []; // æ˜Ÿã®é…åˆ—

        // --- éŸ³å£°è¨­å®š ---
        // Tone.jsã®ã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼å®šç¾© (å¤‰æ›´ãªã—)
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();

        function playSound(type) {
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã€å¿…è¦ãªã‚‰é–‹å§‹/å†é–‹
            if (!Tone.context.state || Tone.context.state !== 'running') {
                 console.log("AudioContext is not running. Trying to resume...");
                 Tone.start().catch(e => console.error("Tone.start failed:", e)); // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
            }

            try {
                switch (type) {
                    case 'shoot': synth.triggerAttackRelease("C5", "16n"); break;
                    case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break;
                    case 'playerHit': metalSynth.triggerAttackRelease("16n"); break;
                    case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break;
                    case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break;
                    case 'gameOver':
                         synth.triggerAttackRelease("C3", "4n", Tone.now());
                         synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2);
                         synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4);
                         synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6);
                         break;
                     case 'missile':
                        const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                        missileNoise.triggerAttackRelease("8n");
                        break;
                    case 'laser': synth.triggerAttackRelease("C6", "32n"); break;
                }
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 20;
        const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7;
        const ENEMY_SPEED_BASE = 2; // æ•µã®åŸºæœ¬é€Ÿåº¦
        const ENEMY_SPAWN_RATE = 900; // æ•µã®å‡ºç¾é »åº¦ã‚’å°‘ã—ä¸Šã’ã‚‹
        const POWERUP_ITEM_SPEED = 1.5;
        const POWERUP_ITEM_WIDTH = 12; // ãƒ¬ãƒƒãƒ‰ãƒ–ãƒ«é¢¨ã‚¢ã‚¤ãƒ†ãƒ ã®å¹…
        const POWERUP_ITEM_HEIGHT = 20; // ãƒ¬ãƒƒãƒ‰ãƒ–ãƒ«é¢¨ã‚¢ã‚¤ãƒ†ãƒ ã®é«˜ã•
        const MISSILE_SPEED = 4;
        const OPTION_DISTANCE = 40;
        const STAR_COUNT = 100;
        const STAR_SPEED_FACTOR = 0.5;

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ---
        let player;
        let projectiles = [];
        let missiles = [];
        let enemies = [];
        let powerUpItemsList = [];
        let options = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let gameRunning = false;
        let lastEnemySpawn = 0;
        let keys = {};
        let currentPowerUpIndex = -1;
        let activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
        let shieldHp = 0;
        let laserActive = false;
        // backgroundOffset ã¯ç¾åœ¨æœªä½¿ç”¨

        // --- ã‚°ãƒ©ãƒ‡ã‚£ã‚¦ã‚¹ã®ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—å®šç¾© ---
        const powerUpTypes = ['speed', 'missile', 'double', 'laser', 'option', 'shield'];

        // --- æ•µã®ç¨®é¡å®šç¾© ---
        const enemyTypes = {
            report: { // å ±å‘Šæ›¸ (æ¨™æº–)
                width: 30, height: 40, color: '#cccccc', health: 1, speedMultiplier: 1,
                value: 100, moveType: 'straight', dropChance: 0.15, drawDetail: drawReportDetail
            },
            spreadsheet: { // Excelã‚·ãƒ¼ãƒˆ (ç¡¬ã„ã€é…ã„)
                width: 40, height: 30, color: '#aaffaa', health: 2, speedMultiplier: 0.8,
                value: 150, moveType: 'straight', dropChance: 0.25, drawDetail: drawSheetDetail
            },
            memo: { // ä»˜ç®‹ (é€Ÿã„ã€ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–)
                width: 20, height: 20, color: '#ffff99', health: 1, speedMultiplier: 1.5,
                value: 120, moveType: 'sine', dropChance: 0.1, drawDetail: drawMemoDetail
            },
             urgent: { // ç·Šæ€¥æ›¸é¡ (éå¸¸ã«é€Ÿã„ã€ç›´ç·š)
                 width: 35, height: 25, color: '#ffaaaa', health: 1, speedMultiplier: 2.0,
                 value: 200, moveType: 'straight', dropChance: 0.3, drawDetail: drawUrgentDetail
             }
        };

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Player {
             constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_WIDTH;
                this.height = PLAYER_HEIGHT;
                this.speed = PLAYER_SPEED_BASE;
                this.shootCooldown = 0;
                this.missileCooldown = 0;
                this.laserDuration = 0;
                this.color = '#00ff00';
                this.invincible = false;
                this.invincibleTimer = 0;
            }

            draw(ctx) {
                // æç”»ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                ctx.fillStyle = this.invincible ? 'rgba(0, 255, 0, 0.5)' : this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10);
                 ctx.fillStyle = '#000000';
                ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10);

                if (activePowerUps.shield && shieldHp > 0) {
                    ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + shieldHp * 0.25})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
            }

            update() {
                 // æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                if (this.invincible) {
                    this.invincibleTimer -= 1000/60;
                    if (this.invincibleTimer <= 0) {
                        this.invincible = false;
                        this.color = '#00ff00';
                    } else {
                        this.color = (Math.floor(this.invincibleTimer / 100) % 2 === 0) ? 'rgba(0, 255, 0, 0.3)' : '#00ff00';
                    }
                }

                if (keys['ArrowUp'] || keys['w']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s']) this.y += this.speed;
                if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d']) this.x += this.speed;

                this.x = Math.max(0, Math.min(this.x, gameWidth - this.width));
                this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));

                if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
                if (this.missileCooldown > 0) this.missileCooldown -= 16.67;
                if (this.laserDuration > 0) this.laserDuration -= 16.67;
                else laserActive = false;

                if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) {
                    this.shoot();
                }

                 if (activePowerUps.missile && this.missileCooldown <= 0) {
                     this.fireMissile();
                     this.missileCooldown = 800;
                 }

                 options.forEach((option, index) => {
                     option.update(this.x, this.y, index);
                 });
            }

             shoot() {
                 // å°„æ’ƒãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                 if (gameOver) return;
                 this.shootCooldown = activePowerUps.laser ? 50 : 200;
                 const projectileY = this.y + this.height / 2 - 2.5;

                 if (activePowerUps.laser) {
                     laserActive = true;
                     this.laserDuration = 150;
                     playSound('laser');
                 } else {
                     projectiles.push(new Projectile(this.x + this.width, projectileY, 'player'));
                     playSound('shoot');
                     if (activePowerUps.double) {
                         projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', Math.PI / 12));
                         projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', -Math.PI / 12));
                     }
                 }
                 options.forEach(option => option.shoot(activePowerUps.laser));
             }


            fireMissile() {
                 // ãƒŸã‚µã‚¤ãƒ«ç™ºå°„ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                 if (gameOver) return;
                 missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down'));
                 missiles.push(new Missile(this.x + this.width / 2, this.y, 'up'));
                 playSound('missile');
            }

             activatePowerUp() {
                 // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ç™ºå‹•ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                 if (currentPowerUpIndex !== -1) {
                    const selectedPowerUp = powerUpTypes[currentPowerUpIndex];
                    playSound('powerupActivate');
                    switch (selectedPowerUp) {
                        case 'speed':
                            activePowerUps.speed++;
                            this.speed = PLAYER_SPEED_BASE + activePowerUps.speed * 1;
                            break;
                        case 'missile': activePowerUps.missile = true; break;
                        case 'double':
                            activePowerUps.double = true;
                            activePowerUps.laser = false;
                            break;
                        case 'laser':
                             activePowerUps.laser = true;
                             activePowerUps.double = false;
                            break;
                        case 'option':
                            if (activePowerUps.option < 2) {
                                activePowerUps.option++;
                                options.push(new Option());
                            }
                            break;
                        case 'shield':
                            activePowerUps.shield = true;
                            shieldHp = 2;
                            break;
                    }
                    updatePowerUpUI();
                    currentPowerUpIndex = -1;
                    highlightPowerUp();
                }
            }

            hit() {
                 // ãƒ’ãƒƒãƒˆå‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                 if (this.invincible) return;
                 playSound('playerHit');
                 if (activePowerUps.shield && shieldHp > 0) {
                     shieldHp--;
                     this.setInvincible(500);
                     if (shieldHp <= 0) {
                         activePowerUps.shield = false;
                         const shieldElement = document.getElementById('shield');
                         if (shieldElement) shieldElement.classList.remove('active');
                     }
                     return;
                 }
                lives--;
                updateLivesDisplay();
                resetPowerUps();
                if (lives <= 0) {
                    gameOver = true;
                    playSound('gameOver');
                    showGameOverMessage();
                } else {
                    this.x = 50;
                    this.y = gameHeight / 2 - PLAYER_HEIGHT / 2;
                    this.setInvincible(2000);
                }
            }

            setInvincible(duration) {
                // ç„¡æ•µè¨­å®šãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
                this.invincible = true;
                this.invincibleTimer = duration;
            }
        }

        // --- å¼¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Projectile {
             constructor(x, y, type, angle = 0) {
                this.x = x; this.y = y; this.width = 10; this.height = 5;
                this.speed = PROJECTILE_SPEED; this.type = type; this.angle = angle;
                this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
            }
            draw(ctx) {
                ctx.fillStyle = this.type === 'player' ? '#ffff00' : '#ff0000';
                 ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                 ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                 ctx.restore();
            }
            update() { this.x += this.vx; this.y += this.vy; }
        }

       // --- ãƒŸã‚µã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Missile {
            constructor(x, y, direction) {
                this.x = x; this.y = y; this.width = 8; this.height = 15;
                this.speed = MISSILE_SPEED; this.direction = direction; this.color = '#00ffff';
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath();
                if (this.direction === 'down') {
                    ctx.moveTo(this.x - this.width / 2, this.y); ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y + this.height);
                } else {
                    ctx.moveTo(this.x - this.width / 2, this.y); ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y - this.height);
                }
                ctx.closePath(); ctx.fill();
            }
            update() {
                if (this.direction === 'down') {
                    this.y += this.speed;
                    if (this.y > gameHeight - this.height - 5) {
                         this.y = gameHeight - this.height - 5; this.x += this.speed / 2; this.direction = 'ground';
                    }
                } else {
                     this.y -= this.speed;
                     if (this.y < this.height + 5) {
                         this.y = this.height + 5; this.x += this.speed / 2; this.direction = 'ceiling';
                     }
                }
                 if (this.direction === 'ground' || this.direction === 'ceiling') {
                     this.x += this.speed / 1.5;
                 }
            }
        }

        // --- æ•µã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (æ›´æ–°) ---
        class Enemy {
             constructor(y, typeName) {
                const type = enemyTypes[typeName] || enemyTypes.report; // ä¸æ˜ãªã‚¿ã‚¤ãƒ—ã¯reportã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

                this.typeName = typeName; // ã‚¿ã‚¤ãƒ—åã‚’ä¿å­˜
                this.width = type.width;
                this.height = type.height;
                this.x = gameWidth;
                this.y = y;
                this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; // ã‚¿ã‚¤ãƒ—ã”ã¨ã«é€Ÿåº¦èª¿æ•´
                this.color = type.color;
                this.health = type.health;
                this.value = type.value;
                this.moveType = type.moveType;
                this.amplitude = Math.random() * 40 + 10; // ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã®æºã‚Œå¹…
                this.frequency = Math.random() * 0.04 + 0.01; // ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã®é€Ÿã•
                this.initialY = y;
                this.canDropPowerUp = Math.random() < type.dropChance; // ã‚¿ã‚¤ãƒ—ã”ã¨ã«ãƒ‰ãƒ­ãƒƒãƒ—ç‡å¤‰æ›´
                this.drawDetail = type.drawDetail; // ã‚¿ã‚¤ãƒ—å›ºæœ‰ã®æç”»é–¢æ•°
            }

            draw(ctx) {
                // åŸºæœ¬çš„ãªçŸ©å½¢æç”»
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // ã‚¿ã‚¤ãƒ—å›ºæœ‰ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«æç”»
                this.drawDetail(ctx, this.x, this.y, this.width, this.height);
            }

            update() {
                this.x -= this.speed;
                if (this.moveType === 'sine') {
                    this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude; // ä½ç›¸ã‚’èª¿æ•´
                    // ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«åˆ¶é™
                    this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                }
            }

            hit() {
                this.health--;
                if (this.health <= 0) {
                    addScore(this.value);
                    playSound('enemyHit');
                     if (this.canDropPowerUp) {
                         dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); // ä¸­å¿ƒã‹ã‚‰ãƒ‰ãƒ­ãƒƒãƒ—
                     }
                    return true; // æ•µã‚’å‰Šé™¤
                }
                // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆè‰²ã‚’ä¸€æ™‚çš„ã«å¤‰ãˆã‚‹ãªã©ï¼‰
                this.color = '#ff0000'; // ä¸€ç¬èµ¤ãã™ã‚‹
                setTimeout(() => {
                    // å…ƒã®è‰²ã«æˆ»ã™ï¼ˆå‹ã®è‰²æƒ…å ±ã‚’ä½¿ã†ï¼‰
                     this.color = enemyTypes[this.typeName]?.color || enemyTypes.report.color;
                }, 50); // 50mså¾Œã«æˆ»ã™
                return false; // æ•µã¯ã¾ã ç”Ÿå­˜
            }
        }

        // --- æ•µã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«æç”»é–¢æ•° ---
        function drawReportDetail(ctx, x, y, w, h) {
            // æ¨™æº–çš„ãªæ›¸é¡ã®ç·š
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 5; i < h - 5; i += 8) {
                ctx.moveTo(x + 5, y + i);
                ctx.lineTo(x + w - 5, y + i);
            }
            ctx.stroke();
        }

        function drawSheetDetail(ctx, x, y, w, h) {
            // æ–¹çœ¼ç´™ã®ã‚ˆã†ãªç·š
            ctx.strokeStyle = '#77cc77'; // å°‘ã—æ¿ƒã„ç·‘
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            // ç¸¦ç·š
            for (let i = 5; i < w; i += 10) {
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
            }
            // æ¨ªç·š
            for (let i = 5; i < h; i += 10) {
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + w, y + i);
            }
            ctx.stroke();
        }

        function drawMemoDetail(ctx, x, y, w, h) {
            // ä»˜ç®‹é¢¨ï¼ˆç‰¹ã«ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ãªã—ã€è‰²ã§è¡¨ç¾ï¼‰
            // å·¦ä¸Šã«å°‘ã—å½±ã‚’ã¤ã‘ã‚‹ï¼Ÿ
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 5, y);
            ctx.lineTo(x, y + 5);
            ctx.closePath();
            ctx.fill();
        }

         function drawUrgentDetail(ctx, x, y, w, h) {
             // ç·Šæ€¥æ›¸é¡é¢¨ï¼ˆèµ¤ã„ã‚¹ã‚¿ãƒ³ãƒ—ï¼‰
             drawReportDetail(ctx, x, y, w, h); // ãƒ™ãƒ¼ã‚¹ã¯ãƒ¬ãƒãƒ¼ãƒˆã¨åŒã˜
             ctx.fillStyle = '#ff0000';
             ctx.font = 'bold 12px "Press Start 2P"';
             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.save();
             ctx.translate(x + w / 2, y + h / 2);
             ctx.rotate(-Math.PI / 12); // å°‘ã—å‚¾ã‘ã‚‹
             ctx.fillText("!", 0, 0); // æ„Ÿå˜†ç¬¦ã§ä»£ç”¨
             ctx.restore();
         }


         // --- ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (æ›´æ–°) ---
        class PowerUpItem {
            constructor(x, y) {
                this.x = x - POWERUP_ITEM_WIDTH / 2; // ä¸­å¿ƒåº§æ¨™åŸºæº–ã§ã‚¹ãƒãƒ¼ãƒ³ã•ã›ã‚‹ãŸã‚èª¿æ•´
                this.y = y - POWERUP_ITEM_HEIGHT / 2;
                this.width = POWERUP_ITEM_WIDTH;
                this.height = POWERUP_ITEM_HEIGHT;
                this.speed = POWERUP_ITEM_SPEED;
                // ãƒ¬ãƒƒãƒ‰ãƒ–ãƒ«é¢¨ã®è‰²
                this.colorTop = '#aaaaee'; // ã‚·ãƒ«ãƒãƒ¼éƒ¨åˆ†
                this.colorBody = '#4444ff'; // é’ã„éƒ¨åˆ†
                this.colorAccent = '#ff4444'; // èµ¤ã„ã‚¢ã‚¯ã‚»ãƒ³ãƒˆ
            }

            draw(ctx) {
                // ãƒ¬ãƒƒãƒ‰ãƒ–ãƒ«é¢¨ã®æç”»
                const topHeight = this.height * 0.2;
                const bodyHeight = this.height * 0.6;
                const bottomHeight = this.height * 0.2;

                // ä¸Šéƒ¨ï¼ˆã‚·ãƒ«ãƒãƒ¼ï¼‰
                ctx.fillStyle = this.colorTop;
                ctx.fillRect(this.x, this.y, this.width, topHeight);

                // ä¸­é–“éƒ¨ï¼ˆé’ï¼‰
                ctx.fillStyle = this.colorBody;
                ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight);

                // ä¸‹éƒ¨ï¼ˆã‚·ãƒ«ãƒãƒ¼ï¼‰
                ctx.fillStyle = this.colorTop;
                ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight);

                // ã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼ˆä¸­å¤®ã®èµ¤ã„è±å½¢é¢¨ï¼‰
                ctx.fillStyle = this.colorAccent;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2);
                ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2);
                ctx.closePath();
                ctx.fill();

                 // "RB" ã®æ–‡å­—ï¼ˆå°ã•ãï¼‰
                 ctx.fillStyle = '#ffffff';
                 ctx.font = 'bold 8px "Press Start 2P"'; // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºèª¿æ•´
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText("RB", this.x + this.width / 2, this.y + this.height / 2 + 1);
            }

            update() {
                this.x -= this.speed; // å·¦ã«ç§»å‹•
            }
        }

        // --- ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå­æ©Ÿï¼‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Option {
            constructor() {
                this.x = 0; this.y = 0; this.size = 15; this.color = '#00aaff';
                this.followDelay = 10; this.history = []; this.shootCooldown = 0;
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
             update(playerX, playerY, index) {
                 this.history.push({ x: playerX, y: playerY });
                 if (this.history.length > this.followDelay * (index + 1)) {
                     this.history.shift();
                 }
                 if (this.history.length > 0) {
                     const targetPos = this.history[0];
                     this.x = targetPos.x; this.y = targetPos.y;
                 } else {
                     this.x = playerX - OPTION_DISTANCE * (index + 1); this.y = playerY;
                 }
                 this.x = Math.max(0, Math.min(this.x, gameWidth - this.size));
                 this.y = Math.max(0, Math.min(this.y, gameHeight - this.size));
                 if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
             }
             shoot(isLaser) {
                 if (this.shootCooldown <= 0) {
                     this.shootCooldown = 200;
                     const projectileY = this.y + this.size / 2 - 2.5;
                     if (isLaser) {
                         projectiles.push(new Projectile(this.x + this.size, projectileY, 'player'));
                         playSound('laser');
                     } else {
                         projectiles.push(new Projectile(this.x + this.size, projectileY, 'player'));
                         playSound('shoot');
                     }
                 }
             }
        }

        // --- æ˜Ÿã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Star {
            constructor() {
                this.x = Math.random() * gameWidth; this.y = Math.random() * gameHeight;
                this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
            update() {
                this.x -= this.speed;
                if (this.x < 0) {
                    this.x = gameWidth; this.y = Math.random() * gameHeight;
                    this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
                }
            }
        }


        // --- åˆæœŸåŒ– ---
        function init() {
            resizeCanvas();
            player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2);
            projectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = [];
            score = 0; lives = 3; gameOver = false; gameRunning = false; lastEnemySpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none';

            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }

            showStartMessage();

            // ãƒªã‚¹ãƒŠãƒ¼ã®å†è¨­å®š
            const newRestartButton = restartButton.cloneNode(true);
            restartButton.parentNode.replaceChild(newRestartButton, restartButton);
            document.getElementById('restartButton').addEventListener('click', startGame);

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šï¼ˆé‡è¤‡ã—ãªã„ã‚ˆã†ã«æ³¨æ„ï¼‰
            window.removeEventListener('keydown', handleKeyDown); // å¤ã„ãƒªã‚¹ãƒŠãƒ¼å‰Šé™¤
            window.removeEventListener('keyup', handleKeyUp);
            window.removeEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', resizeCanvas);
        }

        // --- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºé–¢æ•° (å¤‰æ›´ãªã—) ---
        function showStartMessage() {
             messageText.innerHTML = "ã‚µãƒ©ãƒªãƒ¼ãƒãƒ³ãƒ»ã‚°ãƒ©ãƒ‡ã‚£ã‚¦ã‚¹<br>Arrow Keys/WASD: Move<br>Space/Z: Shoot<br>Shift/X: Activate PowerUp<br><br>PRESS START BUTTON";
             const startButton = document.getElementById('restartButton');
             startButton.textContent = "START GAME";
             messageBox.style.display = 'block';
             gameRunning = false;
        }
        function showGameOverMessage() {
            messageText.innerHTML = `GAME OVER<br>FINAL SCORE: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "RESTART";
            messageBox.style.display = 'block';
            gameRunning = false;
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•° (å¤‰æ›´ãªã—) ---
        function startGame() {
             if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); }
             messageBox.style.display = 'none';
             if (gameOver) { init(); } // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãªã‚‰åˆæœŸåŒ–
             gameOver = false;
             gameRunning = true;
             requestAnimationFrame(gameLoop);
        }


        // --- ãƒªã‚µã‚¤ã‚ºå‡¦ç† (å¤‰æ›´ãªã—) ---
        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth; gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth; canvas.height = gameHeight;
            stars.forEach(star => { star.x = Math.min(star.x, gameWidth); star.y = Math.min(star.y, gameHeight); });
            powerUpBar.style.width = `${gameWidth - 4}px`;
        }

        // --- ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—å‡¦ç† (å¤‰æ›´ãªã—ã€collectPowerUpå†…ã§highlightPowerUpãŒå‘¼ã°ã‚Œã‚‹) ---
        function collectPowerUp() {
             playSound('powerupCollect');
             currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; // ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
             highlightPowerUp(); // â˜…æ¥è§¦æ™‚ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆãŒå¤‰ã‚ã‚‹å‡¦ç†ã¯ã“ã“
        }
        function highlightPowerUp() {
            powerUpItems.forEach((item, index) => {
                item.classList.toggle('highlighted', index === currentPowerUpIndex);
            });
        }
        function updatePowerUpUI() {
             powerUpTypes.forEach((type, index) => { // indexã‚‚ä½¿ã†
                 const element = document.getElementById(type);
                 if (element) {
                     let isActive = false;
                     let text = element.textContent.split(' (')[0]; // åŸºæœ¬ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
                     switch(type) {
                         case 'speed':
                             isActive = activePowerUps.speed > 0;
                             if (isActive) text += ` (${activePowerUps.speed})`;
                             break;
                         case 'option':
                             isActive = activePowerUps.option > 0;
                             if (isActive) text += ` (${activePowerUps.option})`;
                             break;
                         case 'shield':
                             isActive = activePowerUps.shield;
                             text = isActive ? `SHIELD (${shieldHp})` : '? (SHIELD)'; // ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’æ›´æ–°
                             break;
                         default:
                             isActive = activePowerUps[type];
                             break;
                     }
                     element.classList.toggle('active', isActive);
                     element.textContent = text; // æ›´æ–°ã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                 }
             });
        }
        function resetPowerUps(updateUI = true) {
             activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
             if (player) player.speed = PLAYER_SPEED_BASE; // playerãŒå­˜åœ¨ã™ã‚Œã°æ›´æ–°
             options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1;
             if(updateUI) { updatePowerUpUI(); highlightPowerUp(); }
        }
        function dropPowerUpItem(x, y) {
            powerUpItemsList.push(new PowerUpItem(x, y));
        }

        // --- ã‚¹ã‚³ã‚¢ãƒ»ãƒ©ã‚¤ãƒ•æ›´æ–° (å¤‰æ›´ãªã—) ---
        function addScore(amount) { score += amount; updateScoreDisplay(); }
        function updateScoreDisplay() { scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { livesDisplay.innerHTML = `LIVES: ${'ğŸ’–'.repeat(lives)}`; }

        // --- è¡çªåˆ¤å®š (å¤‰æ›´ãªã—) ---
        function checkCollisions() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ vs æ•µ
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(proj, enemy)) {
                        if (enemy.hit()) { enemies.splice(i, 1); }
                        return false;
                    }
                }
                return proj.x < gameWidth;
            });

             // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒŸã‚µã‚¤ãƒ« vs æ•µ
             missiles = missiles.filter(missile => {
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     const missileHitbox = {
                         x: missile.x - missile.width / 2,
                         y: missile.direction === 'down' ? missile.y : missile.y - missile.height,
                         width: missile.width, height: missile.height
                     };
                     if (isColliding(missileHitbox, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                         return false;
                     }
                 }
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
             });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs æ•µ
            if (!player.invincible) {
                enemies.forEach((enemy, index) => { // indexã‚‚å–å¾—
                    if (isColliding(player, enemy)) {
                        player.hit();
                        // æ•µã‚‚æ¶ˆæ»…ã•ã›ã‚‹ï¼ˆä½“å½“ãŸã‚Šï¼‰
                        // splice ã™ã‚‹å‰ã« hit() ã‚’å‘¼ã¶
                        if (enemy.hit()) { // hit() ãŒ true (å€’ã•ã‚ŒãŸ) å ´åˆã®ã¿ splice
                             enemies.splice(index, 1);
                         }
                    }
                });
            }

             // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
             powerUpItemsList = powerUpItemsList.filter(item => {
                 if (isColliding(player, item)) {
                     collectPowerUp();
                     return false;
                 }
                 return item.x > -item.width; // widthåŸºæº–ã«å¤‰æ›´
             });

             // ãƒ¬ãƒ¼ã‚¶ãƒ¼ vs æ•µ
             if (laserActive) {
                 const laserEndX = gameWidth;
                 const laserY = player.y + player.height / 2;
                 const laserRect = { x: player.x + player.width, y: laserY - 2, width: laserEndX - (player.x + player.width), height: 4 };

                 // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‹ã‚‰ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼åˆ¤å®š
                 options.forEach(option => {
                     const optionLaserY = option.y + option.size / 2;
                     const optionLaserRect = { x: option.x + option.size, y: optionLaserY - 2, width: laserEndX - (option.x + option.size), height: 4 };
                     for (let i = enemies.length - 1; i >= 0; i--) {
                         const enemy = enemies[i];
                         if (isColliding(optionLaserRect, enemy)) {
                             if (enemy.hit()) { enemies.splice(i, 1); }
                         }
                     }
                 });

                 // æœ¬ä½“ã‹ã‚‰ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼åˆ¤å®š
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(laserRect, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                     }
                 }
             }
        }
        function isColliding(rect1, rect2) {
            // è¡çªåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // --- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ› (å¤‰æ›´ãªã—) ---
        function handleKeyDown(e) {
             if (!gameRunning && messageBox.style.display === 'block') {
                 if (e.key === 'Shift' || e.key.toLowerCase() === 'x') { e.preventDefault(); return; }
                 if (e.key === ' ' || e.key.toLowerCase() === 'z') { e.preventDefault(); return; }
             } else if (gameRunning) {
                 keys[e.key] = true;
                 if ((e.key === 'Shift' || e.key.toLowerCase() === 'x') && !e.repeat) { player.activatePowerUp(); }
                 if (e.key === ' ' || e.key.toLowerCase() === 'z') { keys[e.key] = true; }
             }
             if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'x', 'w', 'a', 's', 'd'].includes(e.key)) {
                 e.preventDefault();
             }
        }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— (æ›´æ–°) ---
        function gameLoop(timestamp) {
            if (gameOver || !gameRunning) { return; }

            // æ•µã®ç”Ÿæˆ (æ›´æ–°)
            if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) {
                lastEnemySpawn = timestamp;
                // æ•µã‚¿ã‚¤ãƒ—ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                const enemyTypeKeys = Object.keys(enemyTypes);
                const randomTypeKey = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                const enemyType = enemyTypes[randomTypeKey];
                // å‡ºç¾Yåº§æ¨™ã‚’èª¿æ•´ (æ•µã®é«˜ã•è€ƒæ…®)
                const enemyY = Math.random() * (gameHeight - enemyType.height);
                enemies.push(new Enemy(enemyY, randomTypeKey)); // ã‚¿ã‚¤ãƒ—åã‚’æ¸¡ã™
            }

            // æ›´æ–°å‡¦ç†
            player.update();
            projectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update());
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());

            // è¡çªåˆ¤å®š
            checkCollisions();

            // æç”»å‡¦ç†
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            stars.forEach(s => s.draw(ctx));

            player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx)); // æ•µã®æç”» (drawãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã‚¿ã‚¤ãƒ—åˆ¥ã«æç”»)
            powerUpItemsList.forEach(p => p.draw(ctx)); // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®æç”» (ãƒ¬ãƒƒãƒ‰ãƒ–ãƒ«é¢¨)

            // ãƒ¬ãƒ¼ã‚¶ãƒ¼æç”»
             if (laserActive) {
                 ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4;
                 // æœ¬ä½“ãƒ¬ãƒ¼ã‚¶ãƒ¼
                 ctx.beginPath(); ctx.moveTo(player.x + player.width, player.y + player.height / 2);
                 ctx.lineTo(gameWidth, player.y + player.height / 2); ctx.stroke();
                 // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ¬ãƒ¼ã‚¶ãƒ¼
                 options.forEach(option => {
                     ctx.beginPath(); ctx.moveTo(option.x + option.size, option.y + option.size / 2);
                     ctx.lineTo(gameWidth, option.y + option.size / 2); ctx.stroke();
                 });
                 ctx.lineWidth = 1;
             }

             // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—UIæ›´æ–° (å¸¸æ™‚)
             updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        init();

    </script>
</body>
</html>
