<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>サラリーマン・グラディウス (v2)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            flex-direction: column; /* 縦方向に要素を並べる */
        }
        #gameContainer {
            position: relative; /* 相対位置指定 */
            width: 800px; /* ゲーム画面の幅 */
            height: 600px; /* ゲーム画面の高さ */
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden; /* はみ出した要素を隠す */
            margin-bottom: 10px; /* キャンバスとパワーアップバーの間隔 */
        }
        canvas {
            display: block;
            background-color: #111; /* 背景色を少し明るく */
            image-rendering: pixelated; /* ドット絵感を出す */
        }
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: 5px;
            border: 2px solid #fff;
            border-radius: 5px;
            width: 796px; /* コンテナ幅に合わせる */
            box-sizing: border-box; /* paddingとborderを幅に含める */
        }
        .powerUpItem {
            padding: 5px 10px;
            margin: 0 5px;
            border: 1px solid #555;
            color: #888;
            font-size: 12px;
            cursor: default; /* 通常のカーソル */
            transition: all 0.2s ease;
            text-align: center; /* 中央揃えを追加 */
            min-width: 60px; /* 最低幅を確保 */
        }
        .powerUpItem.highlighted {
            background-color: #ffcc00;
            color: #000;
            border-color: #fff;
            box-shadow: 0 0 10px #ffcc00;
        }
        .powerUpItem.active {
            background-color: #ff6600; /* アクティブなパワーアップの色 */
            color: #fff;
            border-color: #fff;
        }
        #uiLayer {
            position: absolute; /* 絶対位置指定 */
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            pointer-events: none; /* UI要素がクリックイベントを妨げないように */
            text-shadow: 1px 1px 2px #000;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border: 2px solid white;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            display: none; /* 初期状態では非表示 */
            z-index: 10;
        }
         #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            background-color: #ffcc00;
            border: 2px solid #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #messageBox button:hover {
            background-color: #ffa500;
        }
        /* 背景の星 (CSSでの実装は削除し、Canvasで描画) */
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 💖💖💖</div>
        </div>
         <div id="messageBox">
            <div id="messageText"></div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="speed">SPEED UP</div>
        <div class="powerUpItem" id="missile">MISSILE</div>
        <div class="powerUpItem" id="double">DOUBLE</div>
        <div class="powerUpItem" id="laser">LASER</div>
        <div class="powerUpItem" id="option">OPTION</div>
        <div class="powerUpItem" id="shield">? (SHIELD)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        let gameWidth, gameHeight; // キャンバスサイズを動的に取得
        let stars = []; // 星の配列

        // --- 音声設定 ---
        // Tone.jsのシンセサイザー定義 (変更なし)
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();

        function playSound(type) {
            // オーディオコンテキストの状態を確認し、必要なら開始/再開
            if (!Tone.context.state || Tone.context.state !== 'running') {
                 console.log("AudioContext is not running. Trying to resume...");
                 Tone.start().catch(e => console.error("Tone.start failed:", e)); // エラーハンドリング追加
            }

            try {
                switch (type) {
                    case 'shoot': synth.triggerAttackRelease("C5", "16n"); break;
                    case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break;
                    case 'playerHit': metalSynth.triggerAttackRelease("16n"); break;
                    case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break;
                    case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break;
                    case 'gameOver':
                         synth.triggerAttackRelease("C3", "4n", Tone.now());
                         synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2);
                         synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4);
                         synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6);
                         break;
                     case 'missile':
                        const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                        missileNoise.triggerAttackRelease("8n");
                        break;
                    case 'laser': synth.triggerAttackRelease("C6", "32n"); break;
                }
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        // --- ゲーム設定 ---
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 20;
        const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7;
        const ENEMY_SPEED_BASE = 2; // 敵の基本速度
        const ENEMY_SPAWN_RATE = 900; // 敵の出現頻度を少し上げる
        const POWERUP_ITEM_SPEED = 1.5;
        const POWERUP_ITEM_WIDTH = 12; // レッドブル風アイテムの幅
        const POWERUP_ITEM_HEIGHT = 20; // レッドブル風アイテムの高さ
        const MISSILE_SPEED = 4;
        const OPTION_DISTANCE = 40;
        const STAR_COUNT = 100;
        const STAR_SPEED_FACTOR = 0.5;

        // --- ゲーム状態 ---
        let player;
        let projectiles = [];
        let missiles = [];
        let enemies = [];
        let powerUpItemsList = [];
        let options = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let gameRunning = false;
        let lastEnemySpawn = 0;
        let keys = {};
        let currentPowerUpIndex = -1;
        let activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
        let shieldHp = 0;
        let laserActive = false;
        // backgroundOffset は現在未使用

        // --- グラディウスのパワーアップ定義 ---
        const powerUpTypes = ['speed', 'missile', 'double', 'laser', 'option', 'shield'];

        // --- 敵の種類定義 ---
        const enemyTypes = {
            report: { // 報告書 (標準)
                width: 30, height: 40, color: '#cccccc', health: 1, speedMultiplier: 1,
                value: 100, moveType: 'straight', dropChance: 0.15, drawDetail: drawReportDetail
            },
            spreadsheet: { // Excelシート (硬い、遅い)
                width: 40, height: 30, color: '#aaffaa', health: 2, speedMultiplier: 0.8,
                value: 150, moveType: 'straight', dropChance: 0.25, drawDetail: drawSheetDetail
            },
            memo: { // 付箋 (速い、サインカーブ)
                width: 20, height: 20, color: '#ffff99', health: 1, speedMultiplier: 1.5,
                value: 120, moveType: 'sine', dropChance: 0.1, drawDetail: drawMemoDetail
            },
             urgent: { // 緊急書類 (非常に速い、直線)
                 width: 35, height: 25, color: '#ffaaaa', health: 1, speedMultiplier: 2.0,
                 value: 200, moveType: 'straight', dropChance: 0.3, drawDetail: drawUrgentDetail
             }
        };

        // --- プレイヤーオブジェクトクラス (変更なし) ---
        class Player {
             constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_WIDTH;
                this.height = PLAYER_HEIGHT;
                this.speed = PLAYER_SPEED_BASE;
                this.shootCooldown = 0;
                this.missileCooldown = 0;
                this.laserDuration = 0;
                this.color = '#00ff00';
                this.invincible = false;
                this.invincibleTimer = 0;
            }

            draw(ctx) {
                // 描画ロジック (変更なし)
                ctx.fillStyle = this.invincible ? 'rgba(0, 255, 0, 0.5)' : this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10);
                 ctx.fillStyle = '#000000';
                ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10);

                if (activePowerUps.shield && shieldHp > 0) {
                    ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + shieldHp * 0.25})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
            }

            update() {
                 // 更新ロジック (変更なし)
                if (this.invincible) {
                    this.invincibleTimer -= 1000/60;
                    if (this.invincibleTimer <= 0) {
                        this.invincible = false;
                        this.color = '#00ff00';
                    } else {
                        this.color = (Math.floor(this.invincibleTimer / 100) % 2 === 0) ? 'rgba(0, 255, 0, 0.3)' : '#00ff00';
                    }
                }

                if (keys['ArrowUp'] || keys['w']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s']) this.y += this.speed;
                if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d']) this.x += this.speed;

                this.x = Math.max(0, Math.min(this.x, gameWidth - this.width));
                this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));

                if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
                if (this.missileCooldown > 0) this.missileCooldown -= 16.67;
                if (this.laserDuration > 0) this.laserDuration -= 16.67;
                else laserActive = false;

                if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) {
                    this.shoot();
                }

                 if (activePowerUps.missile && this.missileCooldown <= 0) {
                     this.fireMissile();
                     this.missileCooldown = 800;
                 }

                 options.forEach((option, index) => {
                     option.update(this.x, this.y, index);
                 });
            }

             shoot() {
                 // 射撃ロジック (変更なし)
                 if (gameOver) return;
                 this.shootCooldown = activePowerUps.laser ? 50 : 200;
                 const projectileY = this.y + this.height / 2 - 2.5;

                 if (activePowerUps.laser) {
                     laserActive = true;
                     this.laserDuration = 150;
                     playSound('laser');
                 } else {
                     projectiles.push(new Projectile(this.x + this.width, projectileY, 'player'));
                     playSound('shoot');
                     if (activePowerUps.double) {
                         projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', Math.PI / 12));
                         projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', -Math.PI / 12));
                     }
                 }
                 options.forEach(option => option.shoot(activePowerUps.laser));
             }


            fireMissile() {
                 // ミサイル発射ロジック (変更なし)
                 if (gameOver) return;
                 missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down'));
                 missiles.push(new Missile(this.x + this.width / 2, this.y, 'up'));
                 playSound('missile');
            }

             activatePowerUp() {
                 // パワーアップ発動ロジック (変更なし)
                 if (currentPowerUpIndex !== -1) {
                    const selectedPowerUp = powerUpTypes[currentPowerUpIndex];
                    playSound('powerupActivate');
                    switch (selectedPowerUp) {
                        case 'speed':
                            activePowerUps.speed++;
                            this.speed = PLAYER_SPEED_BASE + activePowerUps.speed * 1;
                            break;
                        case 'missile': activePowerUps.missile = true; break;
                        case 'double':
                            activePowerUps.double = true;
                            activePowerUps.laser = false;
                            break;
                        case 'laser':
                             activePowerUps.laser = true;
                             activePowerUps.double = false;
                            break;
                        case 'option':
                            if (activePowerUps.option < 2) {
                                activePowerUps.option++;
                                options.push(new Option());
                            }
                            break;
                        case 'shield':
                            activePowerUps.shield = true;
                            shieldHp = 2;
                            break;
                    }
                    updatePowerUpUI();
                    currentPowerUpIndex = -1;
                    highlightPowerUp();
                }
            }

            hit() {
                 // ヒット処理ロジック (変更なし)
                 if (this.invincible) return;
                 playSound('playerHit');
                 if (activePowerUps.shield && shieldHp > 0) {
                     shieldHp--;
                     this.setInvincible(500);
                     if (shieldHp <= 0) {
                         activePowerUps.shield = false;
                         const shieldElement = document.getElementById('shield');
                         if (shieldElement) shieldElement.classList.remove('active');
                     }
                     return;
                 }
                lives--;
                updateLivesDisplay();
                resetPowerUps();
                if (lives <= 0) {
                    gameOver = true;
                    playSound('gameOver');
                    showGameOverMessage();
                } else {
                    this.x = 50;
                    this.y = gameHeight / 2 - PLAYER_HEIGHT / 2;
                    this.setInvincible(2000);
                }
            }

            setInvincible(duration) {
                // 無敵設定ロジック (変更なし)
                this.invincible = true;
                this.invincibleTimer = duration;
            }
        }

        // --- 弾オブジェクトクラス (変更なし) ---
        class Projectile {
             constructor(x, y, type, angle = 0) {
                this.x = x; this.y = y; this.width = 10; this.height = 5;
                this.speed = PROJECTILE_SPEED; this.type = type; this.angle = angle;
                this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
            }
            draw(ctx) {
                ctx.fillStyle = this.type === 'player' ? '#ffff00' : '#ff0000';
                 ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                 ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                 ctx.restore();
            }
            update() { this.x += this.vx; this.y += this.vy; }
        }

       // --- ミサイルオブジェクトクラス (変更なし) ---
        class Missile {
            constructor(x, y, direction) {
                this.x = x; this.y = y; this.width = 8; this.height = 15;
                this.speed = MISSILE_SPEED; this.direction = direction; this.color = '#00ffff';
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath();
                if (this.direction === 'down') {
                    ctx.moveTo(this.x - this.width / 2, this.y); ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y + this.height);
                } else {
                    ctx.moveTo(this.x - this.width / 2, this.y); ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y - this.height);
                }
                ctx.closePath(); ctx.fill();
            }
            update() {
                if (this.direction === 'down') {
                    this.y += this.speed;
                    if (this.y > gameHeight - this.height - 5) {
                         this.y = gameHeight - this.height - 5; this.x += this.speed / 2; this.direction = 'ground';
                    }
                } else {
                     this.y -= this.speed;
                     if (this.y < this.height + 5) {
                         this.y = this.height + 5; this.x += this.speed / 2; this.direction = 'ceiling';
                     }
                }
                 if (this.direction === 'ground' || this.direction === 'ceiling') {
                     this.x += this.speed / 1.5;
                 }
            }
        }

        // --- 敵オブジェクトクラス (更新) ---
        class Enemy {
             constructor(y, typeName) {
                const type = enemyTypes[typeName] || enemyTypes.report; // 不明なタイプはreportにフォールバック

                this.typeName = typeName; // タイプ名を保存
                this.width = type.width;
                this.height = type.height;
                this.x = gameWidth;
                this.y = y;
                this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; // タイプごとに速度調整
                this.color = type.color;
                this.health = type.health;
                this.value = type.value;
                this.moveType = type.moveType;
                this.amplitude = Math.random() * 40 + 10; // サインカーブの揺れ幅
                this.frequency = Math.random() * 0.04 + 0.01; // サインカーブの速さ
                this.initialY = y;
                this.canDropPowerUp = Math.random() < type.dropChance; // タイプごとにドロップ率変更
                this.drawDetail = type.drawDetail; // タイプ固有の描画関数
            }

            draw(ctx) {
                // 基本的な矩形描画
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // タイプ固有のディテール描画
                this.drawDetail(ctx, this.x, this.y, this.width, this.height);
            }

            update() {
                this.x -= this.speed;
                if (this.moveType === 'sine') {
                    this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude; // 位相を調整
                    // 画面外に出ないように制限
                    this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                }
            }

            hit() {
                this.health--;
                if (this.health <= 0) {
                    addScore(this.value);
                    playSound('enemyHit');
                     if (this.canDropPowerUp) {
                         dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); // 中心からドロップ
                     }
                    return true; // 敵を削除
                }
                // ヒットエフェクト（色を一時的に変えるなど）
                this.color = '#ff0000'; // 一瞬赤くする
                setTimeout(() => {
                    // 元の色に戻す（型の色情報を使う）
                     this.color = enemyTypes[this.typeName]?.color || enemyTypes.report.color;
                }, 50); // 50ms後に戻す
                return false; // 敵はまだ生存
            }
        }

        // --- 敵のディテール描画関数 ---
        function drawReportDetail(ctx, x, y, w, h) {
            // 標準的な書類の線
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 5; i < h - 5; i += 8) {
                ctx.moveTo(x + 5, y + i);
                ctx.lineTo(x + w - 5, y + i);
            }
            ctx.stroke();
        }

        function drawSheetDetail(ctx, x, y, w, h) {
            // 方眼紙のような線
            ctx.strokeStyle = '#77cc77'; // 少し濃い緑
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            // 縦線
            for (let i = 5; i < w; i += 10) {
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
            }
            // 横線
            for (let i = 5; i < h; i += 10) {
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + w, y + i);
            }
            ctx.stroke();
        }

        function drawMemoDetail(ctx, x, y, w, h) {
            // 付箋風（特にディテールなし、色で表現）
            // 左上に少し影をつける？
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 5, y);
            ctx.lineTo(x, y + 5);
            ctx.closePath();
            ctx.fill();
        }

         function drawUrgentDetail(ctx, x, y, w, h) {
             // 緊急書類風（赤いスタンプ）
             drawReportDetail(ctx, x, y, w, h); // ベースはレポートと同じ
             ctx.fillStyle = '#ff0000';
             ctx.font = 'bold 12px "Press Start 2P"';
             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.save();
             ctx.translate(x + w / 2, y + h / 2);
             ctx.rotate(-Math.PI / 12); // 少し傾ける
             ctx.fillText("!", 0, 0); // 感嘆符で代用
             ctx.restore();
         }


         // --- パワーアップアイテムオブジェクトクラス (更新) ---
        class PowerUpItem {
            constructor(x, y) {
                this.x = x - POWERUP_ITEM_WIDTH / 2; // 中心座標基準でスポーンさせるため調整
                this.y = y - POWERUP_ITEM_HEIGHT / 2;
                this.width = POWERUP_ITEM_WIDTH;
                this.height = POWERUP_ITEM_HEIGHT;
                this.speed = POWERUP_ITEM_SPEED;
                // レッドブル風の色
                this.colorTop = '#aaaaee'; // シルバー部分
                this.colorBody = '#4444ff'; // 青い部分
                this.colorAccent = '#ff4444'; // 赤いアクセント
            }

            draw(ctx) {
                // レッドブル風の描画
                const topHeight = this.height * 0.2;
                const bodyHeight = this.height * 0.6;
                const bottomHeight = this.height * 0.2;

                // 上部（シルバー）
                ctx.fillStyle = this.colorTop;
                ctx.fillRect(this.x, this.y, this.width, topHeight);

                // 中間部（青）
                ctx.fillStyle = this.colorBody;
                ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight);

                // 下部（シルバー）
                ctx.fillStyle = this.colorTop;
                ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight);

                // アクセント（中央の赤い菱形風）
                ctx.fillStyle = this.colorAccent;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2);
                ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2);
                ctx.closePath();
                ctx.fill();

                 // "RB" の文字（小さく）
                 ctx.fillStyle = '#ffffff';
                 ctx.font = 'bold 8px "Press Start 2P"'; // フォントサイズ調整
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText("RB", this.x + this.width / 2, this.y + this.height / 2 + 1);
            }

            update() {
                this.x -= this.speed; // 左に移動
            }
        }

        // --- オプション（子機）オブジェクトクラス (変更なし) ---
        class Option {
            constructor() {
                this.x = 0; this.y = 0; this.size = 15; this.color = '#00aaff';
                this.followDelay = 10; this.history = []; this.shootCooldown = 0;
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
             update(playerX, playerY, index) {
                 this.history.push({ x: playerX, y: playerY });
                 if (this.history.length > this.followDelay * (index + 1)) {
                     this.history.shift();
                 }
                 if (this.history.length > 0) {
                     const targetPos = this.history[0];
                     this.x = targetPos.x; this.y = targetPos.y;
                 } else {
                     this.x = playerX - OPTION_DISTANCE * (index + 1); this.y = playerY;
                 }
                 this.x = Math.max(0, Math.min(this.x, gameWidth - this.size));
                 this.y = Math.max(0, Math.min(this.y, gameHeight - this.size));
                 if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
             }
             shoot(isLaser) {
                 if (this.shootCooldown <= 0) {
                     this.shootCooldown = 200;
                     const projectileY = this.y + this.size / 2 - 2.5;
                     if (isLaser) {
                         projectiles.push(new Projectile(this.x + this.size, projectileY, 'player'));
                         playSound('laser');
                     } else {
                         projectiles.push(new Projectile(this.x + this.size, projectileY, 'player'));
                         playSound('shoot');
                     }
                 }
             }
        }

        // --- 星オブジェクトクラス (変更なし) ---
        class Star {
            constructor() {
                this.x = Math.random() * gameWidth; this.y = Math.random() * gameHeight;
                this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
            update() {
                this.x -= this.speed;
                if (this.x < 0) {
                    this.x = gameWidth; this.y = Math.random() * gameHeight;
                    this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
                }
            }
        }


        // --- 初期化 ---
        function init() {
            resizeCanvas();
            player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2);
            projectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = [];
            score = 0; lives = 3; gameOver = false; gameRunning = false; lastEnemySpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none';

            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }

            showStartMessage();

            // リスナーの再設定
            const newRestartButton = restartButton.cloneNode(true);
            restartButton.parentNode.replaceChild(newRestartButton, restartButton);
            document.getElementById('restartButton').addEventListener('click', startGame);

            // イベントリスナー設定（重複しないように注意）
            window.removeEventListener('keydown', handleKeyDown); // 古いリスナー削除
            window.removeEventListener('keyup', handleKeyUp);
            window.removeEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', resizeCanvas);
        }

        // --- メッセージ表示関数 (変更なし) ---
        function showStartMessage() {
             messageText.innerHTML = "サラリーマン・グラディウス<br>Arrow Keys/WASD: Move<br>Space/Z: Shoot<br>Shift/X: Activate PowerUp<br><br>PRESS START BUTTON";
             const startButton = document.getElementById('restartButton');
             startButton.textContent = "START GAME";
             messageBox.style.display = 'block';
             gameRunning = false;
        }
        function showGameOverMessage() {
            messageText.innerHTML = `GAME OVER<br>FINAL SCORE: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "RESTART";
            messageBox.style.display = 'block';
            gameRunning = false;
        }

        // --- ゲーム開始関数 (変更なし) ---
        function startGame() {
             if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); }
             messageBox.style.display = 'none';
             if (gameOver) { init(); } // ゲームオーバーからのリスタートなら初期化
             gameOver = false;
             gameRunning = true;
             requestAnimationFrame(gameLoop);
        }


        // --- リサイズ処理 (変更なし) ---
        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth; gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth; canvas.height = gameHeight;
            stars.forEach(star => { star.x = Math.min(star.x, gameWidth); star.y = Math.min(star.y, gameHeight); });
            powerUpBar.style.width = `${gameWidth - 4}px`;
        }

        // --- パワーアップ処理 (変更なし、collectPowerUp内でhighlightPowerUpが呼ばれる) ---
        function collectPowerUp() {
             playSound('powerupCollect');
             currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; // ループするように変更
             highlightPowerUp(); // ★接触時にハイライトが変わる処理はここ
        }
        function highlightPowerUp() {
            powerUpItems.forEach((item, index) => {
                item.classList.toggle('highlighted', index === currentPowerUpIndex);
            });
        }
        function updatePowerUpUI() {
             powerUpTypes.forEach((type, index) => { // indexも使う
                 const element = document.getElementById(type);
                 if (element) {
                     let isActive = false;
                     let text = element.textContent.split(' (')[0]; // 基本のテキストを取得
                     switch(type) {
                         case 'speed':
                             isActive = activePowerUps.speed > 0;
                             if (isActive) text += ` (${activePowerUps.speed})`;
                             break;
                         case 'option':
                             isActive = activePowerUps.option > 0;
                             if (isActive) text += ` (${activePowerUps.option})`;
                             break;
                         case 'shield':
                             isActive = activePowerUps.shield;
                             text = isActive ? `SHIELD (${shieldHp})` : '? (SHIELD)'; // テキスト全体を更新
                             break;
                         default:
                             isActive = activePowerUps[type];
                             break;
                     }
                     element.classList.toggle('active', isActive);
                     element.textContent = text; // 更新したテキストを設定
                 }
             });
        }
        function resetPowerUps(updateUI = true) {
             activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
             if (player) player.speed = PLAYER_SPEED_BASE; // playerが存在すれば更新
             options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1;
             if(updateUI) { updatePowerUpUI(); highlightPowerUp(); }
        }
        function dropPowerUpItem(x, y) {
            powerUpItemsList.push(new PowerUpItem(x, y));
        }

        // --- スコア・ライフ更新 (変更なし) ---
        function addScore(amount) { score += amount; updateScoreDisplay(); }
        function updateScoreDisplay() { scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { livesDisplay.innerHTML = `LIVES: ${'💖'.repeat(lives)}`; }

        // --- 衝突判定 (変更なし) ---
        function checkCollisions() {
            // プレイヤー弾 vs 敵
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(proj, enemy)) {
                        if (enemy.hit()) { enemies.splice(i, 1); }
                        return false;
                    }
                }
                return proj.x < gameWidth;
            });

             // プレイヤーミサイル vs 敵
             missiles = missiles.filter(missile => {
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     const missileHitbox = {
                         x: missile.x - missile.width / 2,
                         y: missile.direction === 'down' ? missile.y : missile.y - missile.height,
                         width: missile.width, height: missile.height
                     };
                     if (isColliding(missileHitbox, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                         return false;
                     }
                 }
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
             });

            // プレイヤー vs 敵
            if (!player.invincible) {
                enemies.forEach((enemy, index) => { // indexも取得
                    if (isColliding(player, enemy)) {
                        player.hit();
                        // 敵も消滅させる（体当たり）
                        // splice する前に hit() を呼ぶ
                        if (enemy.hit()) { // hit() が true (倒された) 場合のみ splice
                             enemies.splice(index, 1);
                         }
                    }
                });
            }

             // プレイヤー vs パワーアップアイテム
             powerUpItemsList = powerUpItemsList.filter(item => {
                 if (isColliding(player, item)) {
                     collectPowerUp();
                     return false;
                 }
                 return item.x > -item.width; // width基準に変更
             });

             // レーザー vs 敵
             if (laserActive) {
                 const laserEndX = gameWidth;
                 const laserY = player.y + player.height / 2;
                 const laserRect = { x: player.x + player.width, y: laserY - 2, width: laserEndX - (player.x + player.width), height: 4 };

                 // オプションからのレーザー判定
                 options.forEach(option => {
                     const optionLaserY = option.y + option.size / 2;
                     const optionLaserRect = { x: option.x + option.size, y: optionLaserY - 2, width: laserEndX - (option.x + option.size), height: 4 };
                     for (let i = enemies.length - 1; i >= 0; i--) {
                         const enemy = enemies[i];
                         if (isColliding(optionLaserRect, enemy)) {
                             if (enemy.hit()) { enemies.splice(i, 1); }
                         }
                     }
                 });

                 // 本体からのレーザー判定
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(laserRect, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                     }
                 }
             }
        }
        function isColliding(rect1, rect2) {
            // 衝突判定ロジック (変更なし)
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // --- キーボード入力 (変更なし) ---
        function handleKeyDown(e) {
             if (!gameRunning && messageBox.style.display === 'block') {
                 if (e.key === 'Shift' || e.key.toLowerCase() === 'x') { e.preventDefault(); return; }
                 if (e.key === ' ' || e.key.toLowerCase() === 'z') { e.preventDefault(); return; }
             } else if (gameRunning) {
                 keys[e.key] = true;
                 if ((e.key === 'Shift' || e.key.toLowerCase() === 'x') && !e.repeat) { player.activatePowerUp(); }
                 if (e.key === ' ' || e.key.toLowerCase() === 'z') { keys[e.key] = true; }
             }
             if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'x', 'w', 'a', 's', 'd'].includes(e.key)) {
                 e.preventDefault();
             }
        }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- ゲームループ (更新) ---
        function gameLoop(timestamp) {
            if (gameOver || !gameRunning) { return; }

            // 敵の生成 (更新)
            if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) {
                lastEnemySpawn = timestamp;
                // 敵タイプをランダムに選択
                const enemyTypeKeys = Object.keys(enemyTypes);
                const randomTypeKey = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                const enemyType = enemyTypes[randomTypeKey];
                // 出現Y座標を調整 (敵の高さ考慮)
                const enemyY = Math.random() * (gameHeight - enemyType.height);
                enemies.push(new Enemy(enemyY, randomTypeKey)); // タイプ名を渡す
            }

            // 更新処理
            player.update();
            projectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update());
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());

            // 衝突判定
            checkCollisions();

            // 描画処理
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            stars.forEach(s => s.draw(ctx));

            player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx)); // 敵の描画 (drawメソッド内でタイプ別に描画)
            powerUpItemsList.forEach(p => p.draw(ctx)); // パワーアップアイテムの描画 (レッドブル風)

            // レーザー描画
             if (laserActive) {
                 ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4;
                 // 本体レーザー
                 ctx.beginPath(); ctx.moveTo(player.x + player.width, player.y + player.height / 2);
                 ctx.lineTo(gameWidth, player.y + player.height / 2); ctx.stroke();
                 // オプションレーザー
                 options.forEach(option => {
                     ctx.beginPath(); ctx.moveTo(option.x + option.size, option.y + option.size / 2);
                     ctx.lineTo(gameWidth, option.y + option.size / 2); ctx.stroke();
                 });
                 ctx.lineWidth = 1;
             }

             // パワーアップUI更新 (常時)
             updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- ゲーム開始 ---
        init();

    </script>
</body>
</html>
