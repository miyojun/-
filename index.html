<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIコーチ VS 学習しない組織 (v14 - 日本語化・画像表示・キー変更・BGM追加)</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">AIコーチ リフレクこ VS 学習しない組織
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        /* 基本スタイル */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* スクロールバーを隠す */
        }
        body {
            display: flex;
            flex-direction: column; /* 縦並び */
            justify-content: center; /* 中央寄せ（垂直） */
            align-items: center; /* 中央寄せ（水平） */
            min-height: 100vh; /* 画面の高さいっぱいに */
        }

        /* ゲームコンテナのレスポンシブ設定 */
        #gameContainer {
            position: relative;
            /* ▼▼▼ 幅とアスペクト比でサイズを決定 ▼▼▼ */
            width: 95vw; /* 画面幅の95% */
            max-width: 960px; /* PCでの最大幅 */
            aspect-ratio: 16 / 10; /* 縦横比を16:10に固定 */
            max-height: 90vh; /* 画面高さの90%を上限に */
            /* ▲▲▲ 幅とアスペクト比でサイズを決定 ▲▲▲ */
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden;
            margin: 10px auto; /* 上下にマージン、左右は自動で中央寄せ */
            box-sizing: border-box;
        }

        /* キャンバス */
        canvas {
            display: block;
            width: 100%; /* コンテナいっぱいに表示 */
            height: 100%; /* コンテナいっぱいに表示 */
            background-color: #111;
            image-rendering: pixelated; /* ドット絵感を維持 */
        }

        /* パワーアップバー */
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: clamp(3px, 0.8vw, 5px); /* 可変パディング */
            border: 2px solid #fff;
            border-radius: 5px;
            /* ▼▼▼ 幅はJSでコンテナに合わせる ▼▼▼ */
            width: 95vw; /* 初期値 (JSで上書き) */
            max-width: 960px; /* PCでの最大幅 */
            /* ▲▲▲ 幅はJSでコンテナに合わせる ▲▲▲ */
            box-sizing: border-box;
            margin: 5px auto 0; /* 上マージン、左右中央 */
            flex-wrap: wrap; /* 小画面で折り返す可能性 */
            gap: clamp(3px, 0.5vw, 5px); /* アイテム間の隙間 */
        }
        .powerUpItem {
            padding: clamp(3px, 0.8vw, 5px) clamp(5px, 1vw, 10px); /* 可変パディング */
            border: 1px solid #555;
            color: #888;
            /* ▼▼▼ フォントサイズを可変に ▼▼▼ */
            font-size: clamp(8px, 1.5vw, 12px);
            /* ▲▲▲ フォントサイズを可変に ▲▲▲ */
            cursor: default;
            transition: all 0.2s ease;
            text-align: center;
            min-width: clamp(60px, 10vw, 90px); /* 可変最小幅 */
            white-space: nowrap;
            flex-grow: 1; /* スペースがあれば広がる */
            flex-basis: 80px; /* 基本幅 */
        }
        .powerUpItem.highlighted { background-color: #ffcc00; color: #000; border-color: #fff; box-shadow: 0 0 10px #ffcc00; }
        .powerUpItem.active { background-color: #ff6600; color: #fff; border-color: #fff; }

        /* UIレイヤー（スコア、ライフ） */
        #uiLayer {
            position: absolute;
            top: clamp(5px, 1vw, 10px); /* 可変 */
            left: clamp(5px, 1vw, 10px); /* 可変 */
            right: clamp(5px, 1vw, 10px); /* 可変 */
            display: flex;
            justify-content: space-between;
            font-size: clamp(10px, 2vw, 16px); /* 可変フォントサイズ */
            pointer-events: none;
            text-shadow: 1px 1px 2px #000;
        }

        /* ボスHPバー */
        #bossHpBar {
            position: absolute;
            bottom: clamp(5px, 1vw, 10px); /* 可変 */
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 300px); /* 可変幅 */
            height: clamp(10px, 1.5vh, 15px); /* 可変高さ */
            border: 2px solid #fff;
            background-color: #555;
            display: none;
            z-index: 5;
        }
        #bossHpFill { width: 100%; height: 100%; background-color: #ff4444; transition: width 0.2s ease-out; }

        /* メッセージボックス */
        #messageBox {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); /* 少し濃く */
            color: white;
            padding: clamp(15px, 3vw, 30px); /* 可変パディング */
            border: 2px solid white;
            border-radius: 10px;
            font-size: clamp(14px, 3vw, 20px); /* 少し小さく */
            text-align: center;
            display: none;
            z-index: 10;
            width: 85%; /* 幅を少し広げる */
            max-width: 550px; /* 最大幅も少し広げる */
            box-sizing: border-box;
        }
        /* ★★★ メッセージボックス内の画像スタイル ★★★ */
        #startImage {
            display: block; /* ブロック要素にして中央寄せしやすく */
            margin: 10px auto 15px; /* 上下にマージン、左右中央 */
            max-width: 80px; /* 最大幅 */
            max-height: 80px; /* 最大高さ */
            border: 1px solid #555; /* 枠線 */
            border-radius: 5px;
        }
        #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.5vw, 16px); /* 可変フォントサイズ */
            padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px); /* 可変パディング */
            margin-top: clamp(10px, 2vh, 15px); /* 少し詰める */
            cursor: pointer;
            background-color: #ffcc00;
            border: 2px solid #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #messageBox button:hover { background-color: #ffa500; }

        /* スマートフォン横向き時の調整 */
        @media (max-width: 960px) and (orientation: landscape) {
            /* 横向きで特に調整が必要な場合ここに記述 */
        }
         @media (max-height: 480px) {
             /* 縦幅が特に小さい画面への対応 */
             #gameContainer {
                 max-height: 95vh; /* 高さをさらに確保 */
             }
             #powerUpBar {
                 margin-top: 3px;
             }
             #uiLayer, #bossHpBar {
                 font-size: clamp(8px, 2vw, 12px); /* UIフォントを小さく */
             }
        }

    </style>
</head>
<body>
    <audio id="bgmAudio" src="Cosmic Gladius.mp3" preload="auto" loop></audio>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 💖💖💖</div>
        </div>
         <div id="bossHpBar"> <div id="bossHpFill"></div>
         </div>
         <div id="messageBox">
             <img id="startImage" src="refleko_right.png" alt="[Image of リフレクこ]">
             <div id="messageText"></div>
             <button id="restartButton">RESTART</button>
         </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="productivity">生産性UP</div>
        <div class="powerUpItem" id="inquiry">問いかけ</div>
        <div class="powerUpItem" id="aiFeedback">AIフィードバック</div>
        <div class="powerUpItem" id="learningBeam">経験学習ビーム</div>
        <div class="powerUpItem" id="aiAgent">AIエージェント</div>
        <div class="powerUpItem" id="safety">心理的安全性</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const bossHpBar = document.getElementById('bossHpBar');
        const bossHpFill = document.getElementById('bossHpFill');
        const startImage = document.getElementById('startImage');
        // ▼▼▼ BGM Audio 要素を取得 ▼▼▼
        const bgmAudio = document.getElementById('bgmAudio');
        // ▲▲▲ BGM Audio 要素を取得 ▲▲▲

        let gameWidth, gameHeight; // キャンバスの解像度
        let stars = [];

        // --- 画像読み込み ---
        const playerImage = new Image(); playerImage.src = 'refleko_right.png';
        let playerImageLoaded = false; playerImage.onload = () => { playerImageLoaded = true; console.log("プレイヤー画像を読み込みました。"); }; playerImage.onerror = () => { console.error("プレイヤー画像の読み込みに失敗しました。"); playerImage.src = 'https://placehold.co/40x40/0f0/fff?text=P'; };
        const optionImage = new Image(); optionImage.src = 'reflect_logo_3.png';
        let optionImageLoaded = false; optionImage.onload = () => { optionImageLoaded = true; console.log("オプション画像を読み込みました。"); }; optionImage.onerror = () => { console.error("オプション画像の読み込みに失敗しました。"); optionImage.src = 'https://placehold.co/38x38/0af/fff?text=O'; };
        const bossImage = new Image(); bossImage.src = 'bigwork.png';
        let bossImageLoaded = false;
        bossImage.onload = () => { bossImageLoaded = true; console.log("ボス画像を読み込みました。"); };
        bossImage.onerror = () => { console.error("ボス画像の読み込みに失敗しました。"); bossImage.src = 'https://placehold.co/200x200/800/fff?text=BOSS'; };
        // ★★★ スタート画像の読み込みエラーハンドリング ★★★
        startImage.onerror = () => {
            console.error("スタート画像の読み込みに失敗しました。");
            startImage.alt = "[スタート画像読み込み失敗]"; // 代替テキスト
            startImage.style.display = 'none'; // 失敗したら非表示に
        };


        // --- 音声設定 ---
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
        const bombSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.4, attackCurve: 'exponential' } }).toDestination();

        function playSound(type) {
             // (音声再生ロジックは変更なし)
             if (!Tone.context.state || Tone.context.state !== 'running') { console.log("AudioContext is not running. Trying to resume..."); Tone.start().catch(e => console.error("Tone.start failed:", e)); }
             try { switch (type) { case 'shoot': synth.triggerAttackRelease("C5", "16n"); break; case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break; case 'playerHit': metalSynth.triggerAttackRelease("16n"); break; case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break; case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break; case 'gameOver': synth.triggerAttackRelease("C3", "4n", Tone.now()); synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4); synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6); break; case 'missile': const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); missileNoise.triggerAttackRelease("8n"); break; case 'laser': synth.triggerAttackRelease("A5", "64n"); break; case 'enemyShoot': bombSynth.triggerAttackRelease("C2", "8n"); break; case 'bossHit': metalSynth.triggerAttackRelease("8n", 0.5); break; case 'bossDefeat': synth.triggerAttackRelease("C6", "2n", Tone.now()); synth.triggerAttackRelease("G5", "2n", Tone.now()+0.1); synth.triggerAttackRelease("E5", "2n", Tone.now()+0.2); synth.triggerAttackRelease("C5", "1n", Tone.now()+0.3); break; } } catch (error) { console.error("Error playing sound:", error); }
        }

        // --- ゲーム設定 (要素のサイズは固定のまま) ---
        let PLAYER_WIDTH = 40; let PLAYER_HEIGHT = 40; const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7; const PROJECTILE_FONT_SIZE = 20;
        const ENEMY_SPEED_BASE = 2; const ENEMY_SPAWN_RATE = 1000; const ENEMY_FONT_SIZE = 18;
        const ENEMY_PROJECTILE_SPEED = 3; const ENEMY_PROJECTILE_FONT_SIZE = 18;
        const POWERUP_ITEM_SPEED = 1.5; const POWERUP_ITEM_WIDTH = 12; const POWERUP_ITEM_HEIGHT = 20;
        const MISSILE_SPEED = 4; const MISSILE_FONT_SIZE = 20;
        const OPTION_WIDTH = 38; const OPTION_HEIGHT = 38;
        const ORBIT_RADIUS = 55;
        const ORBIT_SPEED = 0.05;
        const STAR_COUNT = 100; const STAR_SPEED_FACTOR = 0.5;
        const PLANET_SPAWN_RATE = 8000; const PLANET_SPEED = 0.5;
        const LASER_TEXT = "経験学習-".repeat(7); const LASER_FONT_SIZE = 14;
        const BOSS_TRIGGER_SCORE = 15000;
        const BOSS_WIDTH = 200; const BOSS_HEIGHT = 200; const BOSS_MAX_HEALTH = 150;
        const BOSS_SHOOT_COOLDOWN = 1500; const BOSS_SCORE = 5000;

        // --- ゲーム状態 (変更なし) ---
        let player; let projectiles = []; let enemyProjectiles = []; let missiles = []; let enemies = []; let powerUpItemsList = []; let options = []; let terrain = [];
        let score = 0; let lives = 3; let gameOver = false; let gameWon = false;
        let gameRunning = false;
        let lastEnemySpawn = 0; lastPlanetSpawn = 0;
        let keys = {}; let currentPowerUpIndex = -1;
        let activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false };
        let shieldHp = 0;
        let laserActive = false;
        let enemySpawnPool = [];
        let bossModeActive = false;
        let boss = null;

        const powerUpTypes = ['productivity', 'inquiry', 'aiFeedback', 'learningBeam', 'aiAgent', 'safety'];

        // --- 敵の種類定義 (変更なし) ---
        const enemyTypes = {
            shortage: { text: "人手不足", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffdddd', health: 2, speedMultiplier: 0.9, value: 120, moveType: 'straight', dropChance: 0.15 * 1.5 },
            powerH:   { text: "パワハラ", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffaaaa', health: 1, speedMultiplier: 1.2, value: 150, moveType: 'sine', dropChance: 0.2 * 1.5 },
            overtime: { text: "残業",   width: ENEMY_FONT_SIZE * 2, height: ENEMY_FONT_SIZE * 1.2, color: '#ddddff', health: 3, speedMultiplier: 0.7, value: 100, moveType: 'straight', dropChance: 0.1 * 1.5 },
            sexualH:  { text: "セクハラ", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffccff', health: 1, speedMultiplier: 1.1, value: 140, moveType: 'sine', dropChance: 0.18 * 1.5 },
            turnover: { text: "高離職率", width: ENEMY_FONT_SIZE * 5, height: ENEMY_FONT_SIZE * 1.2, color: '#ffffcc', health: 2, speedMultiplier: 1.0, value: 130, moveType: 'straight', dropChance: 0.22 * 1.5 },
            nonLearningOrg: { text: "学習しない組織", width: ENEMY_FONT_SIZE * 7, height: ENEMY_FONT_SIZE * 1.2, color: '#aaaaaa', health: 5, speedMultiplier: 0.6, value: 300, moveType: 'straight', dropChance: 0.15 * 1.5 },
            resistance: { text: "抵抗勢力", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#cc5555', health: 2, speedMultiplier: 0.5, value: 180, moveType: 'shooter', dropChance: 0.2 * 1.5, shootCooldown: 2500 }
        };

        // --- プレイヤークラス (描画座標は gameWidth/Height に依存) ---
        class Player {
            constructor(x, y) { this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT; this.speed = PLAYER_SPEED_BASE; this.shootCooldown = 0; this.missileCooldown = 0; this.laserDuration = 0; this.invincible = false; this.invincibleTimer = 0; }
            draw(ctx) {
                let drawPlayer = true;
                if (this.invincible) { drawPlayer = Math.floor(this.invincibleTimer / 100) % 2 === 0; }
                if (drawPlayer) {
                    if (playerImageLoaded) { ctx.drawImage(playerImage, this.x, this.y, this.width, this.height); }
                    else { ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10); ctx.fillStyle = '#000000'; ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10); }
                }
                if (activePowerUps.safety && shieldHp > 0) {
                    ctx.save(); ctx.globalAlpha = 0.5 + shieldHp * 0.25; ctx.strokeStyle = `rgba(0, 150, 255, 1)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1;
                }
            }
            update() {
                if (this.invincible) { this.invincibleTimer -= 1000/60; if (this.invincibleTimer <= 0) { this.invincible = false; } }
                // ▼▼▼ 移動範囲を gameWidth/Height に合わせる ▼▼▼
                if (keys['ArrowUp'] || keys['w']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s']) this.y += this.speed;
                if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d']) this.x += this.speed;
                this.x = Math.max(0, Math.min(this.x, gameWidth - this.width));
                this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                // ▲▲▲ 移動範囲を gameWidth/Height に合わせる ▲▲▲
                if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
                if (this.missileCooldown > 0) this.missileCooldown -= 16.67;
                if (this.laserDuration > 0) this.laserDuration -= 16.67; else laserActive = false;
                if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) { this.shoot(); }
                if (activePowerUps.inquiry && this.missileCooldown <= 0) { this.fireMissile(); this.missileCooldown = 800; }
                options.forEach((option, index) => { option.update(this.x, this.y, index); });
            }
            shoot() {
                if (gameOver || gameWon) return;
                this.shootCooldown = activePowerUps.learningBeam ? 50 : 200;
                const projectileY = this.y + this.height / 2;
                if (activePowerUps.learningBeam) {
                    laserActive = true; this.laserDuration = 150; playSound('laser');
                } else {
                    projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', 0, '💬', PROJECTILE_FONT_SIZE));
                    playSound('shoot');
                    if (activePowerUps.aiFeedback) {
                        projectiles.push(new Projectile(this.x + this.width, projectileY - 10, 'player', Math.PI / 18, '💬', PROJECTILE_FONT_SIZE));
                        projectiles.push(new Projectile(this.x + this.width, projectileY + 10, 'player', -Math.PI / 18, '💬', PROJECTILE_FONT_SIZE));
                    }
                }
                options.forEach(option => option.shoot(activePowerUps.learningBeam));
            }
            fireMissile() {
                if (gameOver || gameWon) return;
                missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down'));
                missiles.push(new Missile(this.x + this.width / 2, this.y, 'up'));
                playSound('missile');
            }
            activatePowerUp() {
                if (currentPowerUpIndex !== -1) {
                    const selectedPowerUp = powerUpTypes[currentPowerUpIndex];
                    playSound('powerupActivate');
                    switch (selectedPowerUp) {
                        case 'productivity': activePowerUps.productivity++; this.speed = PLAYER_SPEED_BASE + activePowerUps.productivity * 1; break;
                        case 'inquiry': activePowerUps.inquiry = true; break;
                        case 'aiFeedback': activePowerUps.aiFeedback = true; activePowerUps.learningBeam = false; break;
                        case 'learningBeam': activePowerUps.learningBeam = true; activePowerUps.aiFeedback = false; break;
                        case 'aiAgent': if (activePowerUps.aiAgent < 2) { activePowerUps.aiAgent++; options.push(new Option(options.length)); } break;
                        case 'safety': activePowerUps.safety = true; shieldHp = 2; break;
                    }
                    updatePowerUpUI(); currentPowerUpIndex = -1; highlightPowerUp();
                }
            }
            hit() {
                if (this.invincible || gameWon) return;
                playSound('playerHit');
                if (activePowerUps.safety && shieldHp > 0) {
                    shieldHp--; this.setInvincible(500);
                    if (shieldHp <= 0) { activePowerUps.safety = false; const safetyElement = document.getElementById('safety'); if (safetyElement) safetyElement.classList.remove('active'); }
                    updatePowerUpUI(); return;
                }
                lives--; updateLivesDisplay(); resetPowerUps();
                if (lives <= 0) {
                    gameOver = true;
                    playSound('gameOver');
                    // ▼▼▼ ゲームオーバー時にBGM停止 ▼▼▼
                    if (bgmAudio) {
                        bgmAudio.pause();
                        bgmAudio.currentTime = 0; // 再生位置を最初に戻す
                    }
                    // ▲▲▲ ゲームオーバー時にBGM停止 ▲▲▲
                    showGameOverMessage();
                }
                // ▼▼▼ 復活位置を gameHeight に合わせる ▼▼▼
                else { this.x = 50; this.y = gameHeight / 2 - PLAYER_HEIGHT / 2; this.setInvincible(2000); }
                // ▲▲▲ 復活位置を gameHeight に合わせる ▲▲▲
            }
            setInvincible(duration) { this.invincible = true; this.invincibleTimer = duration; }
        }

        // --- 弾クラス (変更なし) ---
        class Projectile {
            constructor(x, y, type, angle = 0, text = '?', fontSize = 16, speed = PROJECTILE_SPEED) { this.x = x; this.y = y; this.fontSize = fontSize; this.width = this.fontSize; this.height = this.fontSize; this.speed = speed; this.type = type; this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.text = text; }
            draw(ctx) { ctx.font = `${this.fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.type === 'player' ? '#ffffff' : '#ff5555'; ctx.fillText(this.text, this.x, this.y); }
            update() { this.x += this.vx; this.y += this.vy; }
        }

        // --- ミサイルクラス (壁反射位置は gameHeight に依存) ---
        class Missile {
            constructor(x, y, direction) { this.x = x; this.y = y; this.fontSize = MISSILE_FONT_SIZE; this.width = this.fontSize; this.height = this.fontSize; this.speed = MISSILE_SPEED; this.direction = direction; }
            draw(ctx) { ctx.font = `bold ${this.fontSize}px "Press Start 2P"`; ctx.fillStyle = '#ffcc00'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('？', this.x, this.y); }
            update() {
                // ▼▼▼ 壁反射位置を gameHeight に合わせる ▼▼▼
                if (this.direction === 'down') {
                    this.y += this.speed;
                    if (this.y > gameHeight - this.height / 2 - 5) { this.y = gameHeight - this.height / 2 - 5; this.x += this.speed / 2; this.direction = 'ground'; }
                } else { // 'up'
                    this.y -= this.speed;
                    if (this.y < this.height / 2 + 5) { this.y = this.height / 2 + 5; this.x += this.speed / 2; this.direction = 'ceiling'; }
                }
                // ▲▲▲ 壁反射位置を gameHeight に合わせる ▲▲▲
                if (this.direction === 'ground' || this.direction === 'ceiling') { this.x += this.speed / 1.5; }
             }
        }


        // --- 敵クラス (出現位置、移動範囲は gameWidth/Height に依存) ---
        class Enemy {
            constructor(y, typeName) {
                const type = enemyTypes[typeName] || enemyTypes.shortage;
                this.typeName = typeName; this.text = type.text; this.width = type.width; this.height = type.height;
                // ▼▼▼ 出現X座標を gameWidth に合わせる ▼▼▼
                this.x = gameWidth;
                // ▲▲▲ 出現X座標を gameWidth に合わせる ▲▲▲
                this.y = y; this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; this.color = type.color; this.health = type.health; this.value = type.value; this.moveType = type.moveType; this.amplitude = Math.random() * 40 + 10; this.frequency = Math.random() * 0.04 + 0.01; this.initialY = y; this.canDropPowerUp = Math.random() < type.dropChance; if (this.moveType === 'shooter') { this.shootCooldown = type.shootCooldown + (Math.random() * 500 - 250); this.lastShotTime = 0; }
            }
            draw(ctx) { ctx.font = `bold ${ENEMY_FONT_SIZE}px "Press Start 2P"`; ctx.fillStyle = this.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(this.text, this.x, this.y); }
            update(timestamp) {
                this.x -= this.speed;
                if (this.moveType === 'sine') {
                    // ▼▼▼ Y座標移動範囲を gameHeight に合わせる ▼▼▼
                    this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude;
                    this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                    // ▲▲▲ Y座標移動範囲を gameHeight に合わせる ▲▲▲
                } else if (this.moveType === 'shooter' && player) {
                    // ▼▼▼ 射撃開始X座標を gameWidth に合わせる ▼▼▼
                    if (this.x < gameWidth * 0.9 && this.x > 0 && timestamp - this.lastShotTime > this.shootCooldown) {
                    // ▲▲▲ 射撃開始X座標を gameWidth に合わせる ▲▲▲
                        this.shoot(); this.lastShotTime = timestamp; this.shootCooldown = enemyTypes[this.typeName].shootCooldown + (Math.random() * 500 - 250);
                    }
                }
            }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const targetX = player.x + player.width / 2; const targetY = player.y + player.height / 2; const dx = targetX - (this.x); const dy = targetY - (this.y + this.height / 2); const angle = Math.atan2(dy, dx); enemyProjectiles.push(new Projectile( this.x, this.y + this.height / 2, 'enemy', angle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED )); }
            hit() { this.health--; if (this.health <= 0) { addScore(this.value); playSound('enemyHit'); if (this.canDropPowerUp) { dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); } return true; } const originalColor = this.color; this.color = '#ffffff'; setTimeout(() => { this.color = originalColor; }, 60); return false; }
        }

        // --- PowerUpItemクラス (変更なし) ---
        class PowerUpItem {
            constructor(x, y) { this.x = x - POWERUP_ITEM_WIDTH / 2; this.y = y - POWERUP_ITEM_HEIGHT / 2; this.width = POWERUP_ITEM_WIDTH; this.height = POWERUP_ITEM_HEIGHT; this.speed = POWERUP_ITEM_SPEED; this.colorTop = '#aaaaee'; this.colorBody = '#4444ff'; this.colorAccent = '#ff4444'; this.sparkleOffset = 0; this.sparkleSpeed = 0.1; }
            draw(ctx, timestamp) { const topHeight = this.height * 0.2; const bodyHeight = this.height * 0.6; const bottomHeight = this.height * 0.2; ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y, this.width, topHeight); ctx.fillStyle = this.colorBody; ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight); ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight); ctx.fillStyle = this.colorAccent; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2); ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("P", this.x + this.width / 2, this.y + this.height / 2 + 1); ctx.fillStyle = '#ffffaa'; const sparkleSize = 2; const sparkleDistance = Math.max(this.width, this.height) * 0.7; const angle1 = timestamp * 0.005 + this.sparkleOffset; const angle2 = timestamp * 0.005 + Math.PI / 2 + this.sparkleOffset; const angle3 = timestamp * 0.005 + Math.PI + this.sparkleOffset; const angle4 = timestamp * 0.005 + Math.PI * 1.5 + this.sparkleOffset; const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2; ctx.fillRect(centerX + Math.cos(angle1) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle1) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle2) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle2) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle3) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle3) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle4) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle4) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); }
            update() { this.x -= this.speed; }
        }

        // --- Optionクラス (プレイヤー座標に依存) ---
        class Option {
            constructor(index = 0) { this.x = 0; this.y = 0; this.width = OPTION_WIDTH; this.height = OPTION_HEIGHT; this.size = Math.max(this.width, this.height); this.shootCooldown = 0; this.angle = index * Math.PI; }
            draw(ctx) { if (optionImageLoaded) { ctx.drawImage(optionImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } }
            update(playerX, playerY, index) {
                 this.angle += ORBIT_SPEED; if (this.angle > Math.PI * 2) { this.angle -= Math.PI * 2; }
                 const playerCenterX = playerX + PLAYER_WIDTH / 2; const playerCenterY = playerY + PLAYER_HEIGHT / 2;
                 const currentOrbitAngle = this.angle + index * Math.PI;
                 const targetX = playerCenterX + Math.cos(currentOrbitAngle) * ORBIT_RADIUS - this.width / 2;
                 const targetY = playerCenterY + Math.sin(currentOrbitAngle) * ORBIT_RADIUS - this.height / 2;
                 this.x = targetX; this.y = targetY;
                 if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
             }
            shoot(isLaser) { if (this.shootCooldown <= 0) { this.shootCooldown = 200; const projectileY = this.y + this.height / 2; const projectileX = this.x + this.width; if (isLaser) { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '?', PROJECTILE_FONT_SIZE)); playSound('laser'); } else { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '💬', PROJECTILE_FONT_SIZE)); playSound('shoot'); } } }
        }

        // --- Starクラス (出現範囲、移動は gameWidth/Height に依存) ---
        class Star {
            constructor() {
                // ▼▼▼ 出現範囲を gameWidth/Height に合わせる ▼▼▼
                this.x = Math.random() * gameWidth;
                this.y = Math.random() * gameHeight;
                // ▲▲▲ 出現範囲を gameWidth/Height に合わせる ▲▲▲
                this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
            }
            draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
            update() {
                this.x -= this.speed;
                // ▼▼▼ 再出現位置を gameWidth/Height に合わせる ▼▼▼
                if (this.x < 0) { this.x = gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; }
                // ▲▲▲ 再出現位置を gameWidth/Height に合わせる ▲▲▲
            }
        }

        // --- 地形クラス (出現位置は gameWidth に依存) ---
        class Planet {
            constructor(y, radius, color, speed) {
                // ▼▼▼ 出現X座標を gameWidth に合わせる ▼▼▼
                this.x = gameWidth + radius;
                // ▲▲▲ 出現X座標を gameWidth に合わせる ▲▲▲
                this.y = y; this.radius = radius; this.color = color; this.speed = speed;
             }
            draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; const numCraters = Math.floor(this.radius / 10); for (let i = 0; i < numCraters; i++) { const craterRadius = Math.random() * (this.radius * 0.15) + (this.radius * 0.05); const angle = Math.random() * Math.PI * 2; const dist = Math.random() * (this.radius - craterRadius); const craterX = this.x + Math.cos(angle) * dist; const craterY = this.y + Math.sin(angle) * dist; ctx.beginPath(); ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2); ctx.fill(); } }
            update() { this.x -= this.speed; }
            checkCollisionWithRect(rect) { const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width)); const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height)); const distanceX = this.x - closestX; const distanceY = this.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
            checkCollisionWithPoint(point) { const distanceX = this.x - point.x; const distanceY = this.y - point.y; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
        }

        // --- ボスクラス (出現位置、移動範囲は gameWidth/Height に依存) ---
        class Boss {
            constructor() {
                this.width = BOSS_WIDTH; this.height = BOSS_HEIGHT;
                // ▼▼▼ 出現X,Y座標を gameWidth/Height に合わせる ▼▼▼
                this.x = gameWidth;
                this.y = gameHeight / 2 - this.height / 2;
                // ▲▲▲ 出現X,Y座標を gameWidth/Height に合わせる ▲▲▲
                this.speedX = 1.5; this.speedY = 1; this.maxHealth = BOSS_MAX_HEALTH; this.health = this.maxHealth; this.shootCooldown = BOSS_SHOOT_COOLDOWN; this.lastShotTime = 0; this.onScreen = false; this.targetY = this.y; this.hitFlashTimer = 0;
            }
            draw(ctx) {
                let currentImage = bossImage; if (this.hitFlashTimer > 0) { if (Math.floor(this.hitFlashTimer / 50) % 2 === 0) { ctx.globalAlpha = 0.5; } }
                if (bossImageLoaded) { ctx.drawImage(currentImage, this.x, this.y, this.width, this.height); }
                else { ctx.fillStyle = '#880000'; ctx.fillRect(this.x, this.y, this.width, this.height); }
                ctx.globalAlpha = 1.0; bossHpBar.style.display = 'block'; const hpPercentage = Math.max(0, this.health / this.maxHealth) * 100; bossHpFill.style.width = `${hpPercentage}%`;
            }
            update(timestamp) {
                if (this.hitFlashTimer > 0) { this.hitFlashTimer -= 1000 / 60; }
                if (!this.onScreen) {
                    this.x -= this.speedX;
                    // ▼▼▼ 画面内停止位置を gameWidth に合わせる ▼▼▼
                    if (this.x <= gameWidth - this.width - 50) { this.x = gameWidth - this.width - 50; this.onScreen = true; this.lastShotTime = timestamp; }
                    // ▲▲▲ 画面内停止位置を gameWidth に合わせる ▲▲▲
                } else {
                    // ▼▼▼ Y座標移動範囲を gameHeight に合わせる ▼▼▼
                    this.y += this.speedY;
                    if (this.y <= 0 || this.y + this.height >= gameHeight) { this.speedY *= -1; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); }
                    // ▲▲▲ Y座標移動範囲を gameHeight に合わせる ▲▲▲
                    if (timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; }
                }
            }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const shootX = this.x; const shootY = this.y + this.height / 2; const angleToPlayer = Math.atan2(player.y + player.height / 2 - shootY, player.x + player.width / 2 - shootX); const spreadAngle = Math.PI / 9; enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer - spreadAngle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer + spreadAngle, '💣', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); }
            hit() {
                if (this.health <= 0) return false;
                this.health--;
                playSound('bossHit');
                this.hitFlashTimer = 150;
                if (this.health <= 0) {
                    addScore(BOSS_SCORE);
                    playSound('bossDefeat');
                    bossHpBar.style.display = 'none';
                    gameWon = true;
                    // ▼▼▼ ゲームクリア時にBGM停止 ▼▼▼
                    if (bgmAudio) {
                        bgmAudio.pause();
                        bgmAudio.currentTime = 0; // 再生位置を最初に戻す
                    }
                    // ▲▲▲ ゲームクリア時にBGM停止 ▲▲▲
                    showGameWonMessage();
                    return true;
                 }
                 return false;
            }
        }


        // --- 初期化 ---
        function init() {
            // ▼▼▼ resizeCanvas を最初に呼び出す ▼▼▼
            resizeCanvas();
            // ▲▲▲ resizeCanvas を最初に呼び出す ▲▲▲
            player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2); // gameHeight を使う
            projectiles = []; enemyProjectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = []; terrain = [];
            score = 0; lives = 3; gameOver = false; gameWon = false;
            gameRunning = false; lastEnemySpawn = 0; lastPlanetSpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            bossModeActive = false; boss = null; bossHpBar.style.display = 'none';

            // ▼▼▼ BGMを停止（初期化時）▼▼▼
            if (bgmAudio) {
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
            }
            // ▲▲▲ BGMを停止（初期化時）▲▲▲

            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none';
            // ▼▼▼ 星の初期化も resizeCanvas 後に行う ▼▼▼
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push(new Star()); // Starのコンストラクタが gameWidth/Height を使う
            }
            // ▲▲▲ 星の初期化も resizeCanvas 後に行う ▲▲▲
            enemySpawnPool = []; Object.keys(enemyTypes).forEach(key => { const weight = (key === 'resistance') ? 1 : 2; for (let i = 0; i < weight; i++) { enemySpawnPool.push(key); } });
            showStartMessage(); const newRestartButton = restartButton.cloneNode(true); restartButton.parentNode.replaceChild(newRestartButton, restartButton); document.getElementById('restartButton').addEventListener('click', startGame);
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.removeEventListener('resize', handleResize); // ★ リサイズハンドラを変更
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', handleResize); // ★ リサイズイベントに新しいハンドラを設定
            window.addEventListener('orientationchange', handleResize); // ★ 画面回転イベントにも対応
        }

        // --- メッセージ表示関数 ---
        function showStartMessage() {
            // ★★★ 日本語の説明文に変更 ★★★
            messageText.innerHTML = "AIコーチ VS 学習しない組織<br>" +
                                  "操作方法:<br>" +
                                  "移動: 矢印キー / WASD<br>" +
                                  "ショット: Space / Z<br>" +
                                  "パワーアップ発動: Shift + R<br><br>" + // ★★★ キー説明を変更 ★★★
                                  "下のボタンでゲーム開始";
            const startButton = document.getElementById('restartButton');
            startButton.textContent = "ゲームスタート"; // ボタンテキストも日本語に
            // ★★★ スタート画像を表示 ★★★
            startImage.style.display = 'block';
            messageBox.style.display = 'block';
            gameRunning = false;
        }
        function showGameOverMessage() {
            messageText.innerHTML = `ゲームオーバー<br>最終スコア: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "リスタート";
            startImage.style.display = 'none'; // ゲームオーバー時は画像を非表示
            messageBox.style.display = 'block';
            gameRunning = false;
        }
        function showGameWonMessage() {
            messageText.innerHTML = `クリア！<br>おめでとうございます！<br>最終スコア: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "もう一度プレイ";
            startImage.style.display = 'none'; // クリア時も画像を非表示
            messageBox.style.display = 'block';
            gameRunning = false;
        }

        // --- ゲーム開始関数 ---
        function startGame() {
            // SE用のTone.js初期化
            if (Tone.context.state !== 'running') {
                Tone.start().catch(e => console.error("Tone.start failed:", e));
            }

            // ▼▼▼ BGM再生処理を追加 ▼▼▼
            if (bgmAudio) {
                // 再生を試みる (ユーザー操作起因なので許可されるはず)
                const playPromise = bgmAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        // 再生成功
                        console.log("BGM再生開始");
                    }).catch(error => {
                        // 自動再生ポリシーなどで失敗した場合
                        console.error("BGM再生失敗:", error);
                        // ここでユーザーに通知するなどの代替処理も可能
                    });
                }
            }
            // ▲▲▲ BGM再生処理を追加 ▲▲▲


            messageBox.style.display = 'none';
            // ★★★ スタート時に画像を非表示 ★★★
            startImage.style.display = 'none';
            if (gameOver || gameWon) {
                init(); // ゲームオーバー/クリア後の再スタートなら初期化
            }
            gameOver = false;
            gameWon = false;
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // --- リサイズ処理 ---
        // ▼▼▼ リサイズ処理を更新 ▼▼▼
        function resizeCanvas() {
            // gameContainer の実際の表示サイズを取得
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;

            // キャンバスの解像度（内部的な描画サイズ）を設定
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            // ゲーム内で使用する幅と高さを更新
            gameWidth = canvas.width;
            gameHeight = canvas.height;

            // パワーアップバーの幅をコンテナに合わせる
            powerUpBar.style.width = `${containerWidth}px`;
            powerUpBar.style.maxWidth = '960px'; // 最大幅も設定

            // 星の位置を再計算（画面外に出ないように）
            stars.forEach(star => {
                star.x = Math.min(star.x, gameWidth);
                star.y = Math.min(star.y, gameHeight);
            });

            console.log(`Resized canvas to: ${gameWidth}x${gameHeight}`);
        }

        // リサイズイベントのハンドラ（少し遅延させて実行）
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                // 必要であればプレイヤー位置などを再調整
                if (player) {
                     player.x = Math.min(player.x, gameWidth - player.width);
                     player.y = Math.min(player.y, gameHeight - player.height);
                }
            }, 100); // 100ms の遅延
        }
        // ▲▲▲ リサイズ処理を更新 ▲▲▲

        // --- パワーアップ処理 (変更なし) ---
        function collectPowerUp() { playSound('powerupCollect'); currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; highlightPowerUp(); }
        function highlightPowerUp() { powerUpItems.forEach((item, index) => { item.classList.toggle('highlighted', index === currentPowerUpIndex); }); }
        function updatePowerUpUI() {
            powerUpTypes.forEach((type) => {
                const element = document.getElementById(type);
                if (element) {
                    let isActive = false;
                    let text = element.textContent.split(' (')[0]; // 元のテキストを取得
                    switch(type) {
                        case 'productivity': isActive = activePowerUps.productivity > 0; text = isActive ? `生産性UP (${activePowerUps.productivity})` : '生産性UP'; break;
                        case 'aiAgent': isActive = activePowerUps.aiAgent > 0; text = isActive ? `AIエージェント (${activePowerUps.aiAgent})` : 'AIエージェント'; break;
                        case 'safety': isActive = activePowerUps.safety; text = isActive ? `心理的安全性 (${shieldHp})` : '心理的安全性'; break;
                        case 'inquiry': isActive = activePowerUps.inquiry; text = '問いかけ'; break;
                        case 'aiFeedback': isActive = activePowerUps.aiFeedback; text = 'AIフィードバック'; break;
                        case 'learningBeam': isActive = activePowerUps.learningBeam; text = '経験学習ビーム'; break;
                    }
                    element.classList.toggle('active', isActive); element.textContent = text;
                }
            });
        }
        function resetPowerUps(updateUI = true) {
            activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false };
            if (player) player.speed = PLAYER_SPEED_BASE;
            options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1;
            if(updateUI) { updatePowerUpUI(); highlightPowerUp(); }
        }
        function dropPowerUpItem(x, y) { powerUpItemsList.push(new PowerUpItem(x, y)); }

        // --- スコア・ライフ更新 (変更なし) ---
        function addScore(amount) {
            if (gameOver || gameWon) return; score += amount; updateScoreDisplay();
            if (!bossModeActive && score >= BOSS_TRIGGER_SCORE) {
                bossModeActive = true; enemies = []; terrain = []; enemyProjectiles = []; powerUpItemsList = [];
                boss = new Boss(); console.log("BOSS MODE ACTIVATED!");
            }
        }
        function updateScoreDisplay() { scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { livesDisplay.innerHTML = `LIVES: ${'💖'.repeat(lives)}`; }

        // --- 衝突判定 (判定ロジックは gameWidth/Height に依存) ---
        function checkCollisions() {
            if (!player) return;

            // 地形との衝突
            terrain.forEach(planet => {
                if (!player.invincible && planet.checkCollisionWithRect(player)) { player.hit(); }
                projectiles = projectiles.filter(proj => !(proj.type === 'player' && planet.checkCollisionWithPoint(proj)));
                enemyProjectiles = enemyProjectiles.filter(proj => !planet.checkCollisionWithPoint(proj));
                missiles = missiles.filter(missile => !planet.checkCollisionWithPoint({ x: missile.x, y: missile.direction === 'down' ? missile.y + missile.height : missile.y - missile.height }));
            });

            // プレイヤー弾 vs 敵/ボス
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(projHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; }
                }
                if (boss && boss.onScreen && isColliding(projHitbox, boss)) { if (boss.hit()) { boss = null; } return false; }
                // ▼▼▼ 画面外判定を gameWidth に合わせる ▼▼▼
                return proj.x < gameWidth + proj.width;
                // ▲▲▲ 画面外判定を gameWidth に合わせる ▲▲▲
            });

            // 敵弾 vs プレイヤー
            enemyProjectiles = enemyProjectiles.filter(proj => {
                 const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                 if (!player.invincible && isColliding(projHitbox, player)) { player.hit(); return false; }
                 // ▼▼▼ 画面外判定を gameWidth/Height に合わせる ▼▼▼
                 return proj.x > -proj.width && proj.x < gameWidth + proj.width && proj.y > -proj.height && proj.y < gameHeight + proj.height;
                 // ▲▲▲ 画面外判定を gameWidth/Height に合わせる ▲▲▲
             });

            // プレイヤーミサイル vs 敵/ボス
             missiles = missiles.filter(missile => {
                 const missileHitbox = { x: missile.x - missile.width / 2, y: missile.y - missile.height / 2, width: missile.width, height: missile.height };
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(missileHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; }
                 }
                 if (boss && boss.onScreen && isColliding(missileHitbox, boss)) { if (boss.hit()) { boss = null; } return false; }
                 // ▼▼▼ 画面外判定を gameWidth/Height に合わせる ▼▼▼
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
                 // ▲▲▲ 画面外判定を gameWidth/Height に合わせる ▲▲▲
              });

            // プレイヤー vs 敵/ボス
            if (!player.invincible) {
                enemies.forEach((enemy, index) => { if (isColliding(player, enemy)) { player.hit(); if (enemy.hit()) { enemies.splice(index, 1); } } });
                if (boss && boss.onScreen && isColliding(player, boss)) { player.hit(); }
            }

             // プレイヤー vs パワーアップアイテム
             powerUpItemsList = powerUpItemsList.filter(item => { if (isColliding(player, item)) { collectPowerUp(); return false; } return item.x > -item.width; });

             // レーザー vs 敵/ボス (判定ロジックは変更なし、描画座標に依存)
        }
        function isColliding(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- キーボード入力 ---
        function handleKeyDown(e) {
            // メッセージ表示中は特定のキー操作を制限
            if (!gameRunning && messageBox.style.display === 'block') {
                // Shift+R や Space/Z は無効化
                if ((e.shiftKey && e.key.toLowerCase() === 'r') || e.key === ' ' || e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    return;
                }
            } else if (gameRunning) {
                keys[e.key] = true;
                // ★★★ パワーアップ発動キーを Shift + R に変更 ★★★
                if (e.shiftKey && e.key.toLowerCase() === 'r' && !e.repeat) {
                    player.activatePowerUp();
                }
                // スペースまたはZキーの処理 (変更なし)
                if (e.key === ' ' || e.key.toLowerCase() === 'z') {
                    keys[e.key] = true; // 押しっぱなし対応
                }
            }
            // デフォルトのスクロールなどを防ぐキー
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'r', 'w', 'a', 's', 'd'].includes(e.key)) { // 'x' を 'r' に変更
                e.preventDefault();
            }
        }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- ゲームループ (描画/更新は gameWidth/Height に依存) ---
        function gameLoop(timestamp) {
            if (gameOver || gameWon || !gameRunning) { return; }

            // スポーン処理 (ボスモード中は停止)
            if (!bossModeActive) {
                // ▼▼▼ 敵の出現Y座標を gameHeight に合わせる ▼▼▼
                if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) { lastEnemySpawn = timestamp; if (enemySpawnPool.length > 0) { const randomPoolIndex = Math.floor(Math.random() * enemySpawnPool.length); const randomTypeKey = enemySpawnPool[randomPoolIndex]; const enemyType = enemyTypes[randomTypeKey]; const enemyY = Math.random() * (gameHeight - enemyType.height); enemies.push(new Enemy(enemyY, randomTypeKey)); } }
                // ▲▲▲ 敵の出現Y座標を gameHeight に合わせる ▲▲▲
                // ▼▼▼ 地形の出現Y座標を gameHeight に合わせる ▼▼▼
                if (timestamp - lastPlanetSpawn > PLANET_SPAWN_RATE) { lastPlanetSpawn = timestamp; const radius = Math.random() * 50 + 40; const y = Math.random() * (gameHeight - radius * 2) + radius; const color = `hsl(${Math.random() * 60 + 180}, 50%, ${Math.random() * 30 + 40}%)`; const speed = PLANET_SPEED * (Math.random() * 0.5 + 0.75); terrain.push(new Planet(y, radius, color, speed)); }
                // ▲▲▲ 地形の出現Y座標を gameHeight に合わせる ▲▲▲
            }

            // 更新処理
            if(player) player.update();
            projectiles.forEach(p => p.update());
            enemyProjectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update(timestamp));
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());
            terrain = terrain.filter(t => t.x > -t.radius * 2);
            terrain.forEach(t => t.update());
            if (boss) boss.update(timestamp);

            // 衝突判定
            checkCollisions();

            // 描画処理
            // ▼▼▼ 描画範囲を gameWidth/Height に合わせる ▼▼▼
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            // ▲▲▲ 描画範囲を gameWidth/Height に合わせる ▲▲▲
            stars.forEach(s => s.draw(ctx));
            terrain.forEach(t => t.draw(ctx));

            if(player) player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            enemyProjectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            powerUpItemsList.forEach(p => p.draw(ctx, timestamp));
            if (boss) boss.draw(ctx);

            // レーザー描画と衝突判定 (変更なし)
             if (laserActive && player) {
                 ctx.font = `bold ${LASER_FONT_SIZE}px sans-serif`; ctx.fillStyle = '#00aaff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                 const textMetrics = ctx.measureText(LASER_TEXT); const laserWidth = textMetrics.width; const laserHeight = LASER_FONT_SIZE;
                 const laserStartX = player.x + player.width; const laserStartY = player.y + player.height / 2; ctx.fillText(LASER_TEXT, laserStartX, laserStartY); const laserRect = { x: laserStartX, y: laserStartY - laserHeight / 2, width: laserWidth, height: laserHeight };
                 for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(laserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } }
                 if (boss && boss.onScreen && isColliding(laserRect, boss)) { if (boss.hit()) { boss = null; } }
                 terrain.forEach(planet => { if (planet.checkCollisionWithRect(laserRect)) { /* 衝突処理 */ } });
                 options.forEach(option => { const optionLaserStartX = option.x + option.width; const optionLaserStartY = option.y + option.height / 2; ctx.fillText(LASER_TEXT, optionLaserStartX, optionLaserStartY); const optionLaserRect = { x: optionLaserStartX, y: optionLaserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(optionLaserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(optionLaserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(optionLaserRect)) { /* 衝突処理 */ } }); });
             }

            updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- ゲーム開始 ---
        init(); // 初期化処理を実行

    </script>
</body>
</html>
