<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI„Ç≥„Éº„ÉÅ VS Â≠¶Áøí„Åó„Å™„ÅÑÁµÑÁπî (v10 - „Éú„ÇπÊù°‰ª∂„ÉªÂπÖÂ§âÊõ¥)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #222; margin: 0; font-family: 'Press Start 2P', cursive; color: #fff; flex-direction: column; }
        #gameContainer {
            position: relative;
            width: 960px; /* ‚òÖ Ê®™ÂπÖ„Çí960px„Å´Â§âÊõ¥ */
            height: 600px;
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden;
            margin-bottom: 10px;
        }
        canvas { display: block; background-color: #111; image-rendering: pixelated; }
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: 5px;
            border: 2px solid #fff;
            border-radius: 5px;
            width: 956px; /* ‚òÖ „Ç≥„É≥„ÉÜ„ÉäÂπÖ„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥ (960 - 4) */
            box-sizing: border-box;
        }
        .powerUpItem { padding: 5px 10px; margin: 0 5px; border: 1px solid #555; color: #888; font-size: 12px; cursor: default; transition: all 0.2s ease; text-align: center; min-width: 60px; }
        .powerUpItem.highlighted { background-color: #ffcc00; color: #000; border-color: #fff; box-shadow: 0 0 10px #ffcc00; }
        .powerUpItem.active { background-color: #ff6600; color: #fff; border-color: #fff; }
        #uiLayer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 16px; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        #bossHpBar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 300px; height: 15px; border: 2px solid #fff; background-color: #555; display: none; z-index: 5; }
        #bossHpFill { width: 100%; height: 100%; background-color: #ff4444; transition: width 0.2s ease-out; }
        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 30px; border: 2px solid white; border-radius: 10px; font-size: 24px; text-align: center; display: none; z-index: 10; }
        #messageBox button { font-family: 'Press Start 2P', cursive; font-size: 16px; padding: 10px 20px; margin-top: 20px; cursor: pointer; background-color: #ffcc00; border: 2px solid #fff; color: #000; border-radius: 5px; transition: background-color 0.3s; }
        #messageBox button:hover { background-color: #ffa500; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: üíñüíñüíñ</div>
        </div>
         <div id="bossHpBar"> <div id="bossHpFill"></div>
         </div>
         <div id="messageBox">
            <div id="messageText"></div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="speed">SPEED UP</div>
        <div class="powerUpItem" id="missile">MISSILE</div>
        <div class="powerUpItem" id="double">DOUBLE</div>
        <div class="powerUpItem" id="laser">LASER</div>
        <div class="powerUpItem" id="option">OPTION</div>
        <div class="powerUpItem" id="shield">? (SHIELD)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const bossHpBar = document.getElementById('bossHpBar');
        const bossHpFill = document.getElementById('bossHpFill');

        let gameWidth, gameHeight;
        let stars = [];

        // --- ÁîªÂÉèË™≠„ÅøËæº„Åø (Â§âÊõ¥„Å™„Åó) ---
        const playerImage = new Image(); playerImage.src = 'refleko_right.png';
        let playerImageLoaded = false; playerImage.onload = () => { playerImageLoaded = true; console.log("„Éó„É¨„Ç§„É§„ÉºÁîªÂÉè„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ"); }; playerImage.onerror = () => { console.error("„Éó„É¨„Ç§„É§„ÉºÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ"); };
        const optionImage = new Image(); optionImage.src = 'reflect_logo_3.png';
        let optionImageLoaded = false; optionImage.onload = () => { optionImageLoaded = true; console.log("„Ç™„Éó„Ç∑„Éß„É≥ÁîªÂÉè„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ"); }; optionImage.onerror = () => { console.error("„Ç™„Éó„Ç∑„Éß„É≥ÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ"); };
        const bossImage = new Image(); bossImage.src = 'bigwork.png';
        let bossImageLoaded = false;
        bossImage.onload = () => { bossImageLoaded = true; console.log("„Éú„ÇπÁîªÂÉè„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ"); };
        bossImage.onerror = () => { console.error("„Éú„ÇπÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ"); };


        // --- Èü≥Â£∞Ë®≠ÂÆö (Â§âÊõ¥„Å™„Åó) ---
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
        const bombSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.4, attackCurve: 'exponential' } }).toDestination();

        function playSound(type) { /* ...Â§âÊõ¥„Å™„Åó... */
             if (!Tone.context.state || Tone.context.state !== 'running') { console.log("AudioContext is not running. Trying to resume..."); Tone.start().catch(e => console.error("Tone.start failed:", e)); }
            try { switch (type) { case 'shoot': synth.triggerAttackRelease("C5", "16n"); break; case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break; case 'playerHit': metalSynth.triggerAttackRelease("16n"); break; case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break; case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break; case 'gameOver': synth.triggerAttackRelease("C3", "4n", Tone.now()); synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4); synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6); break; case 'missile': const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); missileNoise.triggerAttackRelease("8n"); break; case 'laser': synth.triggerAttackRelease("A5", "64n"); break; case 'enemyShoot': bombSynth.triggerAttackRelease("C2", "8n"); break; case 'bossHit': metalSynth.triggerAttackRelease("8n", 0.5); break; case 'bossDefeat': synth.triggerAttackRelease("C6", "2n", Tone.now()); synth.triggerAttackRelease("G5", "2n", Tone.now()+0.1); synth.triggerAttackRelease("E5", "2n", Tone.now()+0.2); synth.triggerAttackRelease("C5", "1n", Tone.now()+0.3); break; } } catch (error) { console.error("Error playing sound:", error); }
        }

        // --- „Ç≤„Éº„É†Ë®≠ÂÆö (‚òÖ BOSS_TRIGGER_SCORE Â§âÊõ¥) ---
        let PLAYER_WIDTH = 40; let PLAYER_HEIGHT = 40; const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7; const PROJECTILE_FONT_SIZE = 20;
        const ENEMY_SPEED_BASE = 2; const ENEMY_SPAWN_RATE = 1000; const ENEMY_FONT_SIZE = 18;
        const ENEMY_PROJECTILE_SPEED = 3; const ENEMY_PROJECTILE_FONT_SIZE = 18;
        const POWERUP_ITEM_SPEED = 1.5; const POWERUP_ITEM_WIDTH = 12; const POWERUP_ITEM_HEIGHT = 20;
        const MISSILE_SPEED = 4; const MISSILE_FONT_SIZE = 20;
        const OPTION_WIDTH = 38; const OPTION_HEIGHT = 38; const OPTION_DISTANCE = 68;
        const STAR_COUNT = 100; const STAR_SPEED_FACTOR = 0.5;
        const PLANET_SPAWN_RATE = 8000; const PLANET_SPEED = 0.5;
        const LASER_TEXT = "ÁµåÈ®ìÂ≠¶Áøí-".repeat(7); const LASER_FONT_SIZE = 14;
        const BOSS_TRIGGER_SCORE = 15000; // ‚òÖ „Éú„ÇπÂá∫Áèæ„Çπ„Ç≥„Ç¢„Çí15000„Å´Â§âÊõ¥
        const BOSS_WIDTH = 200; const BOSS_HEIGHT = 200; const BOSS_MAX_HEALTH = 150;
        const BOSS_SHOOT_COOLDOWN = 1500; const BOSS_SCORE = 5000;

        // --- „Ç≤„Éº„É†Áä∂ÊÖã (Â§âÊõ¥„Å™„Åó) ---
        let player; let projectiles = []; let enemyProjectiles = []; let missiles = []; let enemies = []; let powerUpItemsList = []; let options = []; let terrain = [];
        let score = 0; let lives = 3; let gameOver = false; let gameWon = false;
        let gameRunning = false;
        let lastEnemySpawn = 0; let lastPlanetSpawn = 0;
        let keys = {}; let currentPowerUpIndex = -1;
        let activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false };
        let shieldHp = 0; let laserActive = false;
        let enemySpawnPool = [];
        let bossModeActive = false;
        let boss = null;

        const powerUpTypes = ['speed', 'missile', 'double', 'laser', 'option', 'shield'];

        // --- Êïµ„ÅÆÁ®ÆÈ°ûÂÆöÁæ© (Â§âÊõ¥„Å™„Åó) ---
        const enemyTypes = { /* ...Â§âÊõ¥„Å™„Åó... */
            shortage: { text: "‰∫∫Êâã‰∏çË∂≥", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffdddd', health: 2, speedMultiplier: 0.9, value: 120, moveType: 'straight', dropChance: 0.15 * 1.5 },
            powerH:   { text: "„Éë„ÉØ„Éè„É©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffaaaa', health: 1, speedMultiplier: 1.2, value: 150, moveType: 'sine', dropChance: 0.2 * 1.5 },
            overtime: { text: "ÊÆãÊ•≠",   width: ENEMY_FONT_SIZE * 2, height: ENEMY_FONT_SIZE * 1.2, color: '#ddddff', health: 3, speedMultiplier: 0.7, value: 100, moveType: 'straight', dropChance: 0.1 * 1.5 },
            sexualH:  { text: "„Çª„ÇØ„Éè„É©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffccff', health: 1, speedMultiplier: 1.1, value: 140, moveType: 'sine', dropChance: 0.18 * 1.5 },
            turnover: { text: "È´òÈõ¢ËÅ∑Áéá", width: ENEMY_FONT_SIZE * 5, height: ENEMY_FONT_SIZE * 1.2, color: '#ffffcc', health: 2, speedMultiplier: 1.0, value: 130, moveType: 'straight', dropChance: 0.22 * 1.5 },
            nonLearningOrg: { text: "Â≠¶Áøí„Åó„Å™„ÅÑÁµÑÁπî", width: ENEMY_FONT_SIZE * 7, height: ENEMY_FONT_SIZE * 1.2, color: '#aaaaaa', health: 5, speedMultiplier: 0.6, value: 300, moveType: 'straight', dropChance: 0.15 * 1.5 },
            resistance: { text: "ÊäµÊäóÂã¢Âäõ", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#cc5555', health: 2, speedMultiplier: 0.5, value: 180, moveType: 'shooter', dropChance: 0.2 * 1.5, shootCooldown: 2500 }
        };

        // --- „Éó„É¨„Ç§„É§„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Player { /* ...Â§âÊõ¥„Å™„Åó... */
             constructor(x, y) { this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT; this.speed = PLAYER_SPEED_BASE; this.shootCooldown = 0; this.missileCooldown = 0; this.laserDuration = 0; this.invincible = false; this.invincibleTimer = 0; }
            draw(ctx) { let drawPlayer = true; if (this.invincible) { drawPlayer = Math.floor(this.invincibleTimer / 100) % 2 === 0; } if (drawPlayer) { if (playerImageLoaded) { ctx.drawImage(playerImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10); ctx.fillStyle = '#000000'; ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10); } } if (activePowerUps.shield && shieldHp > 0) { ctx.save(); ctx.globalAlpha = 0.5 + shieldHp * 0.25; ctx.strokeStyle = `rgba(0, 150, 255, 1)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1; } }
            update() { if (this.invincible) { this.invincibleTimer -= 1000/60; if (this.invincibleTimer <= 0) { this.invincible = false; } } if (keys['ArrowUp'] || keys['w']) this.y -= this.speed; if (keys['ArrowDown'] || keys['s']) this.y += this.speed; if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed; if (keys['ArrowRight'] || keys['d']) this.x += this.speed; this.x = Math.max(0, Math.min(this.x, gameWidth - this.width)); this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); if (this.shootCooldown > 0) this.shootCooldown -= 16.67; if (this.missileCooldown > 0) this.missileCooldown -= 16.67; if (this.laserDuration > 0) this.laserDuration -= 16.67; else laserActive = false; if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) { this.shoot(); } if (activePowerUps.missile && this.missileCooldown <= 0) { this.fireMissile(); this.missileCooldown = 800; } options.forEach((option, index) => { option.update(this.x, this.y, index); }); }
             shoot() { if (gameOver || gameWon) return; this.shootCooldown = activePowerUps.laser ? 50 : 200; const projectileY = this.y + this.height / 2; if (activePowerUps.laser) { laserActive = true; this.laserDuration = 150; playSound('laser'); } else { projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', 0, 'üí¨', PROJECTILE_FONT_SIZE)); playSound('shoot'); if (activePowerUps.double) { projectiles.push(new Projectile(this.x + this.width, projectileY - 10, 'player', Math.PI / 18, 'üí¨', PROJECTILE_FONT_SIZE)); projectiles.push(new Projectile(this.x + this.width, projectileY + 10, 'player', -Math.PI / 18, 'üí¨', PROJECTILE_FONT_SIZE)); } } options.forEach(option => option.shoot(activePowerUps.laser)); }
            fireMissile() { if (gameOver || gameWon) return; missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down')); missiles.push(new Missile(this.x + this.width / 2, this.y, 'up')); playSound('missile'); }
            activatePowerUp() { if (currentPowerUpIndex !== -1) { const selectedPowerUp = powerUpTypes[currentPowerUpIndex]; playSound('powerupActivate'); switch (selectedPowerUp) { case 'speed': activePowerUps.speed++; this.speed = PLAYER_SPEED_BASE + activePowerUps.speed * 1; break; case 'missile': activePowerUps.missile = true; break; case 'double': activePowerUps.double = true; activePowerUps.laser = false; break; case 'laser': activePowerUps.laser = true; activePowerUps.double = false; break; case 'option': if (activePowerUps.option < 2) { activePowerUps.option++; options.push(new Option()); } break; case 'shield': activePowerUps.shield = true; shieldHp = 2; break; } updatePowerUpUI(); currentPowerUpIndex = -1; highlightPowerUp(); } }
            hit() { if (this.invincible || gameWon) return; playSound('playerHit'); if (activePowerUps.shield && shieldHp > 0) { shieldHp--; this.setInvincible(500); if (shieldHp <= 0) { activePowerUps.shield = false; const shieldElement = document.getElementById('shield'); if (shieldElement) shieldElement.classList.remove('active'); } return; } lives--; updateLivesDisplay(); resetPowerUps(); if (lives <= 0) { gameOver = true; playSound('gameOver'); showGameOverMessage(); } else { this.x = 50; this.y = gameHeight / 2 - PLAYER_HEIGHT / 2; this.setInvincible(2000); } }
            setInvincible(duration) { this.invincible = true; this.invincibleTimer = duration; }
        }

        // --- Âºæ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Projectile { /* ...Â§âÊõ¥„Å™„Åó... */
             constructor(x, y, type, angle = 0, text = '?', fontSize = 16, speed = PROJECTILE_SPEED) { this.x = x; this.y = y; this.fontSize = fontSize; this.width = this.fontSize; this.height = this.fontSize; this.speed = speed; this.type = type; this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.text = text; }
            draw(ctx) { ctx.font = `${this.fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.type === 'player' ? '#ffffff' : '#ff5555'; ctx.fillText(this.text, this.x, this.y); }
            update() { this.x += this.vx; this.y += this.vy; }
        }

        // --- „Éü„Çµ„Ç§„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Missile { /* ...Â§âÊõ¥„Å™„Åó... */
            constructor(x, y, direction) { this.x = x; this.y = y; this.fontSize = MISSILE_FONT_SIZE; this.width = this.fontSize; this.height = this.fontSize; this.speed = MISSILE_SPEED; this.direction = direction; }
            draw(ctx) { ctx.font = `bold ${this.fontSize}px "Press Start 2P"`; ctx.fillStyle = '#ff0000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('Ôºü', this.x, this.y); }
            update() { if (this.direction === 'down') { this.y += this.speed; if (this.y > gameHeight - this.height / 2 - 5) { this.y = gameHeight - this.height / 2 - 5; this.x += this.speed / 2; this.direction = 'ground'; } } else { this.y -= this.speed; if (this.y < this.height / 2 + 5) { this.y = this.height / 2 + 5; this.x += this.speed / 2; this.direction = 'ceiling'; } } if (this.direction === 'ground' || this.direction === 'ceiling') { this.x += this.speed / 1.5; } }
        }


        // --- Êïµ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Enemy { /* ...Â§âÊõ¥„Å™„Åó... */
             constructor(y, typeName) { const type = enemyTypes[typeName] || enemyTypes.shortage; this.typeName = typeName; this.text = type.text; this.width = type.width; this.height = type.height; this.x = gameWidth; this.y = y; this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; this.color = type.color; this.health = type.health; this.value = type.value; this.moveType = type.moveType; this.amplitude = Math.random() * 40 + 10; this.frequency = Math.random() * 0.04 + 0.01; this.initialY = y; this.canDropPowerUp = Math.random() < type.dropChance; if (this.moveType === 'shooter') { this.shootCooldown = type.shootCooldown + (Math.random() * 500 - 250); this.lastShotTime = 0; } }
            draw(ctx) { ctx.font = `bold ${ENEMY_FONT_SIZE}px "Press Start 2P"`; ctx.fillStyle = this.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(this.text, this.x, this.y); }
            update(timestamp) { this.x -= this.speed; if (this.moveType === 'sine') { this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); } else if (this.moveType === 'shooter' && player) { if (this.x < gameWidth * 0.9 && this.x > 0 && timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; this.shootCooldown = enemyTypes[this.typeName].shootCooldown + (Math.random() * 500 - 250); } } }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const targetX = player.x + player.width / 2; const targetY = player.y + player.height / 2; const dx = targetX - (this.x); const dy = targetY - (this.y + this.height / 2); const angle = Math.atan2(dy, dx); enemyProjectiles.push(new Projectile( this.x, this.y + this.height / 2, 'enemy', angle, 'üí£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED )); }
            hit() { this.health--; if (this.health <= 0) { addScore(this.value); playSound('enemyHit'); if (this.canDropPowerUp) { dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); } return true; } const originalColor = this.color; this.color = '#ffffff'; setTimeout(() => { this.color = originalColor; }, 60); return false; }
        }

        // --- PowerUpItem„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class PowerUpItem { /* ...Â§âÊõ¥„Å™„Åó... */
            constructor(x, y) { this.x = x - POWERUP_ITEM_WIDTH / 2; this.y = y - POWERUP_ITEM_HEIGHT / 2; this.width = POWERUP_ITEM_WIDTH; this.height = POWERUP_ITEM_HEIGHT; this.speed = POWERUP_ITEM_SPEED; this.colorTop = '#aaaaee'; this.colorBody = '#4444ff'; this.colorAccent = '#ff4444'; this.sparkleOffset = 0; this.sparkleSpeed = 0.1; }
            draw(ctx, timestamp) { const topHeight = this.height * 0.2; const bodyHeight = this.height * 0.6; const bottomHeight = this.height * 0.2; ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y, this.width, topHeight); ctx.fillStyle = this.colorBody; ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight); ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight); ctx.fillStyle = this.colorAccent; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2); ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("RB", this.x + this.width / 2, this.y + this.height / 2 + 1); ctx.fillStyle = '#ffffaa'; const sparkleSize = 2; const sparkleDistance = Math.max(this.width, this.height) * 0.7; const angle1 = timestamp * 0.005 + this.sparkleOffset; const angle2 = timestamp * 0.005 + Math.PI / 2 + this.sparkleOffset; const angle3 = timestamp * 0.005 + Math.PI + this.sparkleOffset; const angle4 = timestamp * 0.005 + Math.PI * 1.5 + this.sparkleOffset; const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2; ctx.fillRect(centerX + Math.cos(angle1) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle1) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle2) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle2) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle3) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle3) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle4) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle4) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); }
            update() { this.x -= this.speed; }
        }

        // --- Option„ÇØ„É©„Çπ (‚òÖ ÂÆöÊï∞Â§âÊõ¥ÈÅ©Áî®) ---
        class Option {
            constructor() {
                this.x = 0; this.y = 0;
                this.width = OPTION_WIDTH; // ‚òÖ ÂÆöÊï∞‰ΩøÁî®
                this.height = OPTION_HEIGHT; // ‚òÖ ÂÆöÊï∞‰ΩøÁî®
                this.size = Math.max(this.width, this.height);
                this.followDelay = 10; this.history = []; this.shootCooldown = 0;
            }
            draw(ctx) { /* ...ÊèèÁîª„É≠„Ç∏„ÉÉ„ÇØÂ§âÊõ¥„Å™„Åó... */ if (optionImageLoaded) { ctx.drawImage(optionImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } }
            update(playerX, playerY, index) { /* ...ËøΩÂæì„É≠„Ç∏„ÉÉ„ÇØÂ§âÊõ¥„Å™„Åó (OPTION_DISTANCE‰ΩøÁî®)... */ this.history.push({ x: playerX, y: playerY }); if (this.history.length > this.followDelay * (index + 1)) { this.history.shift(); } if (this.history.length > 0) { const targetPos = this.history[0]; this.x = targetPos.x; this.y = targetPos.y; } else { this.x = playerX - OPTION_DISTANCE * (index + 1); this.y = playerY; } this.x = Math.max(0, Math.min(this.x, gameWidth - this.width)); this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); if (this.shootCooldown > 0) this.shootCooldown -= 16.67; }
             shoot(isLaser) { /* ...Â∞ÑÊíÉ„É≠„Ç∏„ÉÉ„ÇØÂ§âÊõ¥„Å™„Åó... */ if (this.shootCooldown <= 0) { this.shootCooldown = 200; const projectileY = this.y + this.height / 2; const projectileX = this.x + this.width; if (isLaser) { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '?', PROJECTILE_FONT_SIZE)); playSound('laser'); } else { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, 'üí¨', PROJECTILE_FONT_SIZE)); playSound('shoot'); } } }
        }

        // --- Star„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Star { /* ...Â§âÊõ¥„Å™„Åó... */
            constructor() { this.x = Math.random() * gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; }
            draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
            update() { this.x -= this.speed; if (this.x < 0) { this.x = gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; } }
        }

        // --- Âú∞ÂΩ¢ÔºàÊÉëÊòüÔºâ„ÇØ„É©„Çπ (Â§âÊõ¥„Å™„Åó) ---
        class Planet { /* ...Â§âÊõ¥„Å™„Åó... */
            constructor(y, radius, color, speed) { this.x = gameWidth + radius; this.y = y; this.radius = radius; this.color = color; this.speed = speed; }
            draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; const numCraters = Math.floor(this.radius / 10); for (let i = 0; i < numCraters; i++) { const craterRadius = Math.random() * (this.radius * 0.15) + (this.radius * 0.05); const angle = Math.random() * Math.PI * 2; const dist = Math.random() * (this.radius - craterRadius); const craterX = this.x + Math.cos(angle) * dist; const craterY = this.y + Math.sin(angle) * dist; ctx.beginPath(); ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2); ctx.fill(); } }
            update() { this.x -= this.speed; }
            checkCollisionWithRect(rect) { const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width)); const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height)); const distanceX = this.x - closestX; const distanceY = this.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
            checkCollisionWithPoint(point) { const distanceX = this.x - point.x; const distanceY = this.y - point.y; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
        }

        // --- ‚òÖ „Éú„Çπ„ÇØ„É©„Çπ ---
        class Boss {
            constructor() {
                this.width = BOSS_WIDTH;
                this.height = BOSS_HEIGHT;
                this.x = gameWidth; // ÁîªÈù¢Âè≥Â§ñ„Åã„Çâ
                this.y = gameHeight / 2 - this.height / 2; // ‰∏≠Â§Æ„ÅÆÈ´ò„Åï
                this.speedX = 1.5; // ÁôªÂ†¥ÊôÇ„ÅÆÊ®™ÁßªÂãïÈÄüÂ∫¶
                this.speedY = 1;   // ÁôªÂ†¥Âæå„ÅÆÁ∏¶ÁßªÂãïÈÄüÂ∫¶
                this.maxHealth = BOSS_MAX_HEALTH;
                this.health = this.maxHealth;
                this.shootCooldown = BOSS_SHOOT_COOLDOWN;
                this.lastShotTime = 0;
                this.onScreen = false; // ÁîªÈù¢ÂÜÖ„Å´ÂÆåÂÖ®„Å´ÁôªÂ†¥„Åó„Åü„Åã
                this.targetY = this.y; // Á∏¶ÁßªÂãï„ÅÆÁõÆÊ®ôYÂ∫ßÊ®ô
                this.hitFlashTimer = 0; // Ë¢´ÂºæÊôÇ„ÅÆ„Éï„É©„ÉÉ„Ç∑„É•„Çø„Ç§„Éû„Éº
            }

            draw(ctx) {
                let currentImage = bossImage;
                // Ë¢´Âºæ„Éï„É©„ÉÉ„Ç∑„É•
                if (this.hitFlashTimer > 0) {
                    if (Math.floor(this.hitFlashTimer / 50) % 2 === 0) {
                       ctx.globalAlpha = 0.5;
                    }
                }

                if (bossImageLoaded) {
                    ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
                } else {
                    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                    ctx.fillStyle = '#880000'; // Êöó„ÅÑËµ§
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                ctx.globalAlpha = 1.0; // ÈÄèÊòéÂ∫¶„ÇíÊàª„Åô

                // HP„Éê„ÉºÊõ¥Êñ∞ („Éú„ÇπÂá∫Áèæ‰∏≠„ÅÆ„ÅøË°®Á§∫)
                bossHpBar.style.display = 'block';
                const hpPercentage = Math.max(0, this.health / this.maxHealth) * 100;
                bossHpFill.style.width = `${hpPercentage}%`;
            }

            update(timestamp) {
                // Ë¢´Âºæ„Éï„É©„ÉÉ„Ç∑„É•„Çø„Ç§„Éû„ÉºÊ∏õÂ∞ë
                if (this.hitFlashTimer > 0) {
                    this.hitFlashTimer -= 1000 / 60; // 1„Éï„É¨„Éº„É†ÊôÇÈñì(ms)
                }


                if (!this.onScreen) {
                    // ÁîªÈù¢ÂÜÖ„Å´ÁßªÂãï
                    this.x -= this.speedX;
                    if (this.x <= gameWidth - this.width - 50) { // ÁîªÈù¢Âè≥Á´Ø„Åã„ÇâÂ∞ë„ÅóÂÜÖÂÅ¥„Å∏
                        this.x = gameWidth - this.width - 50;
                        this.onScreen = true;
                        this.lastShotTime = timestamp; // ÁîªÈù¢„Å´Âá∫„Å¶„Åã„ÇâÂ∞ÑÊíÉÈñãÂßã
                    }
                } else {
                    // ÁîªÈù¢ÂÜÖ„Åß„ÅÆ‰∏ä‰∏ãÁßªÂãï
                    this.y += this.speedY;
                    if (this.y <= 0 || this.y + this.height >= gameHeight) {
                        this.speedY *= -1; // Á´Ø„Å´ÂΩì„Åü„Å£„Åü„ÇâÂèçËª¢
                        this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); // ÁîªÈù¢ÂÜÖ„Å´Âèé„ÇÅ„Çã
                    }

                    // Â∞ÑÊíÉ
                    if (timestamp - this.lastShotTime > this.shootCooldown) {
                        this.shoot();
                        this.lastShotTime = timestamp;
                    }
                }
            }

            shoot() {
                if (!player || gameOver || gameWon) return;
                playSound('enemyShoot'); // Êïµ„Å®Âêå„ÅòÂ∞ÑÊíÉÈü≥„Çí‰ΩøÁî®
                const shootX = this.x; // „Éú„Çπ„ÅÆÂ∑¶Á´Ø„Åã„Çâ
                const shootY = this.y + this.height / 2; // „Éú„Çπ„ÅÆ‰∏≠ÂøÉÈ´ò„Åï„Åã„Çâ

                const angleToPlayer = Math.atan2(player.y + player.height / 2 - shootY, player.x + player.width / 2 - shootX);
                const spreadAngle = Math.PI / 9; // ÊîæÂ∞ÑÁä∂„ÅÆËßíÂ∫¶ (3Áô∫„Åß60Â∫¶„Åè„Çâ„ÅÑ)

                // 3ÊñπÂêë„Å´Áô∫Â∞Ñ
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer - spreadAngle, 'üí£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer, 'üí£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
                enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer + spreadAngle, 'üí£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED));
            }

            hit() {
                if (this.health <= 0) return false; // „Åô„Åß„Å´ÂÄí„Åï„Çå„Å¶„ÅÑ„Çã

                this.health--;
                playSound('bossHit');
                this.hitFlashTimer = 150; // „Éï„É©„ÉÉ„Ç∑„É•ÊôÇÈñì(ms)

                if (this.health <= 0) {
                    addScore(BOSS_SCORE);
                    playSound('bossDefeat');
                    bossHpBar.style.display = 'none'; // HP„Éê„Éº„ÇíÈö†„Åô
                    gameWon = true; // ‚òÖ „Ç≤„Éº„É†„ÇØ„É™„Ç¢
                    showGameWonMessage();
                    // ‚òÖ ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà„Å™„Å©„Çí„Åì„Åì„Å´ËøΩÂä†ÂèØËÉΩ
                    return true; // ÂÄí„Åï„Çå„Åü
                }
                return false; // „Åæ„Å†ÁîüÂ≠ò
            }
        }


        // --- ÂàùÊúüÂåñ (‚òÖ „Éú„ÇπÈñ¢ÈÄ£„É™„Çª„ÉÉ„ÉàËøΩÂä†) ---
        function init() {
            resizeCanvas(); player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2);
            projectiles = []; enemyProjectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = []; terrain = [];
            score = 0; lives = 3; gameOver = false; gameWon = false; // ‚òÖ gameWon„É™„Çª„ÉÉ„Éà
            gameRunning = false; lastEnemySpawn = 0; lastPlanetSpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            bossModeActive = false; // ‚òÖ bossMode„É™„Çª„ÉÉ„Éà
            boss = null; // ‚òÖ boss„É™„Çª„ÉÉ„Éà
            bossHpBar.style.display = 'none'; // ‚òÖ HP„Éê„ÉºÈùûË°®Á§∫

            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none'; stars = []; for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            enemySpawnPool = []; Object.keys(enemyTypes).forEach(key => { const weight = (key === 'resistance') ? 1 : 2; for (let i = 0; i < weight; i++) { enemySpawnPool.push(key); } });
            showStartMessage(); const newRestartButton = restartButton.cloneNode(true); restartButton.parentNode.replaceChild(newRestartButton, restartButton); document.getElementById('restartButton').addEventListener('click', startGame);
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.removeEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); window.addEventListener('resize', resizeCanvas);
        }

        // --- „É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫Èñ¢Êï∞ („Ç≤„Éº„É†„ÇØ„É™„Ç¢„É°„ÉÉ„Çª„Éº„Ç∏ËøΩÂä†) ---
        function showStartMessage() { /* ...Â§âÊõ¥„Å™„Åó... */ messageText.innerHTML = "AI„Ç≥„Éº„ÉÅ VS Â≠¶Áøí„Åó„Å™„ÅÑÁµÑÁπî<br>Arrow Keys/WASD: Move<br>Space/Z: Shoot<br>Shift/X: Activate PowerUp<br><br>PRESS START BUTTON"; const startButton = document.getElementById('restartButton'); startButton.textContent = "START GAME"; messageBox.style.display = 'block'; gameRunning = false; }
        function showGameOverMessage() { /* ...Â§âÊõ¥„Å™„Åó... */ messageText.innerHTML = `GAME OVER<br>FINAL SCORE: ${score}`; const restartBtn = document.getElementById('restartButton'); restartBtn.textContent = "RESTART"; messageBox.style.display = 'block'; gameRunning = false; }
        function showGameWonMessage() { // ‚òÖ „Ç≤„Éº„É†„ÇØ„É™„Ç¢„É°„ÉÉ„Çª„Éº„Ç∏
            messageText.innerHTML = `CONGRATULATIONS!<br>YOU WIN!<br>FINAL SCORE: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "PLAY AGAIN?";
            messageBox.style.display = 'block';
            gameRunning = false; // „Ç≤„Éº„É†„É´„Éº„ÉóÂÅúÊ≠¢
        }

        // --- „Ç≤„Éº„É†ÈñãÂßãÈñ¢Êï∞ (Â§âÊõ¥„Å™„Åó) ---
        function startGame() { /* ...Â§âÊõ¥„Å™„Åó... */ if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.start failed:", e)); } messageBox.style.display = 'none'; if (gameOver || gameWon) { init(); } gameOver = false; gameWon = false; gameRunning = true; requestAnimationFrame(gameLoop); }

        // --- „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜ (‚òÖ „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Éê„Éº„ÅÆÂπÖË™øÊï¥„ÇÇ„Åì„Åì„ÅßË°å„ÅÜ) ---
        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth;
            gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;
            stars.forEach(star => { star.x = Math.min(star.x, gameWidth); star.y = Math.min(star.y, gameHeight); });
            // ‚òÖ „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Éê„Éº„ÅÆÂπÖ„ÇÇÂãïÁöÑ„Å´Ë™øÊï¥
            powerUpBar.style.width = `${gameWidth - 4}px`;
        }

        // --- „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂá¶ÁêÜ (Â§âÊõ¥„Å™„Åó) ---
        function collectPowerUp() { /* ...Â§âÊõ¥„Å™„Åó... */ playSound('powerupCollect'); currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; highlightPowerUp(); }
        function highlightPowerUp() { /* ...Â§âÊõ¥„Å™„Åó... */ powerUpItems.forEach((item, index) => { item.classList.toggle('highlighted', index === currentPowerUpIndex); }); }
        function updatePowerUpUI() { /* ...Â§âÊõ¥„Å™„Åó... */ powerUpTypes.forEach((type, index) => { const element = document.getElementById(type); if (element) { let isActive = false; let text = element.textContent.split(' (')[0]; switch(type) { case 'speed': isActive = activePowerUps.speed > 0; if (isActive) text += ` (${activePowerUps.speed})`; break; case 'option': isActive = activePowerUps.option > 0; if (isActive) text += ` (${activePowerUps.option})`; break; case 'shield': isActive = activePowerUps.shield; text = isActive ? `SHIELD (${shieldHp})` : '? (SHIELD)'; break; default: isActive = activePowerUps[type]; break; } element.classList.toggle('active', isActive); element.textContent = text; } }); }
        function resetPowerUps(updateUI = true) { /* ...Â§âÊõ¥„Å™„Åó... */ activePowerUps = { speed: 0, missile: false, double: false, laser: false, option: 0, shield: false }; if (player) player.speed = PLAYER_SPEED_BASE; options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1; if(updateUI) { updatePowerUpUI(); highlightPowerUp(); } }
        function dropPowerUpItem(x, y) { /* ...Â§âÊõ¥„Å™„Åó... */ powerUpItemsList.push(new PowerUpItem(x, y)); }

        // --- „Çπ„Ç≥„Ç¢„Éª„É©„Ç§„ÉïÊõ¥Êñ∞ (‚òÖ „Éú„Çπ„É¢„Éº„Éâ„Éà„É™„Ç¨„ÉºËøΩÂä†) ---
        function addScore(amount) {
            if (gameOver || gameWon) return; // „Ç≤„Éº„É†ÁµÇ‰∫ÜÂæå„ÅØ„Çπ„Ç≥„Ç¢Âä†ÁÆó„Åó„Å™„ÅÑ
            score += amount;
            updateScoreDisplay();

            // ‚òÖ „Éú„Çπ„É¢„Éº„Éâ„Éà„É™„Ç¨„Éº
            if (!bossModeActive && score >= BOSS_TRIGGER_SCORE) {
                bossModeActive = true;
                // Êó¢Â≠ò„ÅÆÊïµ„ÉªÂú∞ÂΩ¢„ÉªÊïµÂºæ„Çí„ÇØ„É™„Ç¢
                enemies = [];
                terrain = [];
                enemyProjectiles = [];
                powerUpItemsList = []; // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„ÇÇÊ∂à„Åô
                // „Éú„ÇπÁîüÊàê
                boss = new Boss();
                console.log("BOSS MODE ACTIVATED!");
                // TODO: "WARNING"„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫„Å™„Å©Ôºü
            }
        }
        function updateScoreDisplay() { /* ...Â§âÊõ¥„Å™„Åó... */ scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { /* ...Â§âÊõ¥„Å™„Åó... */ livesDisplay.innerHTML = `LIVES: ${'üíñ'.repeat(lives)}`; }

        // --- Ë°ùÁ™ÅÂà§ÂÆö (‚òÖ „Éú„ÇπÈñ¢ÈÄ£ËøΩÂä†) ---
        function checkCollisions() {
            if (!player) return; // „Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÂà§ÂÆö„Åó„Å™„ÅÑ

            // Âú∞ÂΩ¢„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
            terrain.forEach(planet => {
                if (!player.invincible && planet.checkCollisionWithRect(player)) { player.hit(); }
                projectiles = projectiles.filter(proj => !(proj.type === 'player' && planet.checkCollisionWithPoint(proj)));
                enemyProjectiles = enemyProjectiles.filter(proj => !planet.checkCollisionWithPoint(proj));
                missiles = missiles.filter(missile => !planet.checkCollisionWithPoint({ x: missile.x, y: missile.direction === 'down' ? missile.y + missile.height : missile.y - missile.height }));
            });

            // „Éó„É¨„Ç§„É§„ÉºÂºæ vs Êïµ/„Éú„Çπ
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                // ÈÄöÂ∏∏Êïµ
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(projHitbox, enemy)) {
                        if (enemy.hit()) { enemies.splice(i, 1); }
                        return false; // ÂºæÊ∂àÊªÖ
                    }
                }
                // „Éú„Çπ
                if (boss && boss.onScreen && isColliding(projHitbox, boss)) {
                     if (boss.hit()) { boss = null; } // „Éú„Çπ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂâäÈô§
                     return false; // ÂºæÊ∂àÊªÖ
                }
                return proj.x < gameWidth + proj.width; // ÁîªÈù¢Â§ñÂà§ÂÆö
            });

            // ÊïµÂºæ vs „Éó„É¨„Ç§„É§„Éº
            enemyProjectiles = enemyProjectiles.filter(proj => {
                 const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                 if (!player.invincible && isColliding(projHitbox, player)) {
                    player.hit();
                    return false;
                }
                return proj.x > -proj.width && proj.x < gameWidth + proj.width && proj.y > -proj.height && proj.y < gameHeight + proj.height;
            });

            // „Éó„É¨„Ç§„É§„Éº„Éü„Çµ„Ç§„É´ vs Êïµ/„Éú„Çπ
             missiles = missiles.filter(missile => {
                 const missileHitbox = { x: missile.x - missile.width / 2, y: missile.y - missile.height / 2, width: missile.width, height: missile.height };
                 // ÈÄöÂ∏∏Êïµ
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(missileHitbox, enemy)) {
                         if (enemy.hit()) { enemies.splice(i, 1); }
                         return false;
                     }
                 }
                 // „Éú„Çπ
                 if (boss && boss.onScreen && isColliding(missileHitbox, boss)) {
                     if (boss.hit()) { boss = null; }
                     return false;
                 }
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
             });

            // „Éó„É¨„Ç§„É§„Éº vs Êïµ/„Éú„Çπ
            if (!player.invincible) {
                // ÈÄöÂ∏∏Êïµ
                enemies.forEach((enemy, index) => { if (isColliding(player, enemy)) { player.hit(); if (enemy.hit()) { enemies.splice(index, 1); } } });
                // „Éú„Çπ
                if (boss && boss.onScreen && isColliding(player, boss)) {
                    player.hit(); // „Éú„Çπ„Å´Êé•Ëß¶„Åó„Å¶„ÇÇÂç≥Ê≠ª
                }
            }

             // „Éó„É¨„Ç§„É§„Éº vs „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†
             powerUpItemsList = powerUpItemsList.filter(item => { if (isColliding(player, item)) { collectPowerUp(); return false; } return item.x > -item.width; });

             // „É¨„Éº„Ç∂„Éº vs Êïµ/„Éú„Çπ („É¨„Éº„Ç∂„ÉºÊèèÁîªÊôÇ„Å´Âà§ÂÆö)
        }
        function isColliding(rect1, rect2) { /* ...Â§âÊõ¥„Å™„Åó... */ return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ (Â§âÊõ¥„Å™„Åó) ---
        function handleKeyDown(e) { /* ...Â§âÊõ¥„Å™„Åó... */ if (!gameRunning && messageBox.style.display === 'block') { if (e.key === 'Shift' || e.key.toLowerCase() === 'x') { e.preventDefault(); return; } if (e.key === ' ' || e.key.toLowerCase() === 'z') { e.preventDefault(); return; } } else if (gameRunning) { keys[e.key] = true; if ((e.key === 'Shift' || e.key.toLowerCase() === 'x') && !e.repeat) { player.activatePowerUp(); } if (e.key === ' ' || e.key.toLowerCase() === 'z') { keys[e.key] = true; } } if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'x', 'w', 'a', 's', 'd'].includes(e.key)) { e.preventDefault(); } }
        function handleKeyUp(e) { /* ...Â§âÊõ¥„Å™„Åó... */ keys[e.key] = false; }

        // --- „Ç≤„Éº„É†„É´„Éº„Éó (‚òÖ „Éú„ÇπÂá¶ÁêÜ„ÄÅ„Çπ„Éù„Éº„É≥Âà∂Âæ°ËøΩÂä†) ---
        function gameLoop(timestamp) {
            if (gameOver || gameWon || !gameRunning) { // ‚òÖ gameWon„Åß„ÇÇÂÅúÊ≠¢
                return;
            }

            // „Çπ„Éù„Éº„É≥Âá¶ÁêÜ (‚òÖ „Éú„Çπ„É¢„Éº„Éâ‰∏≠„ÅØÂÅúÊ≠¢)
            if (!bossModeActive) {
                // Êïµ
                if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) { lastEnemySpawn = timestamp; if (enemySpawnPool.length > 0) { const randomPoolIndex = Math.floor(Math.random() * enemySpawnPool.length); const randomTypeKey = enemySpawnPool[randomPoolIndex]; const enemyType = enemyTypes[randomTypeKey]; const enemyY = Math.random() * (gameHeight - enemyType.height); enemies.push(new Enemy(enemyY, randomTypeKey)); } }
                // Âú∞ÂΩ¢
                if (timestamp - lastPlanetSpawn > PLANET_SPAWN_RATE) { lastPlanetSpawn = timestamp; const radius = Math.random() * 50 + 40; const y = Math.random() * (gameHeight - radius * 2) + radius; const color = `hsl(${Math.random() * 60 + 180}, 50%, ${Math.random() * 30 + 40}%)`; const speed = PLANET_SPEED * (Math.random() * 0.5 + 0.75); terrain.push(new Planet(y, radius, color, speed)); }
            }

            // Êõ¥Êñ∞Âá¶ÁêÜ
            if(player) player.update();
            projectiles.forEach(p => p.update());
            enemyProjectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update(timestamp));
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());
            terrain = terrain.filter(t => t.x > -t.radius * 2); // ÁîªÈù¢Â∑¶Á´Ø„ÅßÊ∂à„Åô
            terrain.forEach(t => t.update());
            options.forEach(o => o.update(player?.x ?? 0, player?.y ?? 0, options.indexOf(o)));
            if (boss) boss.update(timestamp); // ‚òÖ „Éú„Çπ„ÅÆÊõ¥Êñ∞

            // Ë°ùÁ™ÅÂà§ÂÆö
            checkCollisions();

            // ÊèèÁîªÂá¶ÁêÜ
            ctx.clearRect(0, 0, gameWidth, gameHeight); ctx.fillStyle = '#111'; ctx.fillRect(0, 0, gameWidth, gameHeight);
            stars.forEach(s => s.draw(ctx));
            terrain.forEach(t => t.draw(ctx));

            if(player) player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            enemyProjectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            powerUpItemsList.forEach(p => p.draw(ctx, timestamp));
            if (boss) boss.draw(ctx); // ‚òÖ „Éú„Çπ„ÅÆÊèèÁîª

            // „É¨„Éº„Ç∂„ÉºÊèèÁîª„Å®Ë°ùÁ™ÅÂà§ÂÆö (‚òÖ „Éú„Çπ„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöËøΩÂä†)
             if (laserActive && player) {
                 ctx.font = `bold ${LASER_FONT_SIZE}px sans-serif`; ctx.fillStyle = '#00aaff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                 const textMetrics = ctx.measureText(LASER_TEXT); const laserWidth = textMetrics.width; const laserHeight = LASER_FONT_SIZE;

                 // Êú¨‰Ωì„É¨„Éº„Ç∂„ÉºÂá¶ÁêÜ
                 const laserStartX = player.x + player.width; const laserStartY = player.y + player.height / 2; ctx.fillText(LASER_TEXT, laserStartX, laserStartY); const laserRect = { x: laserStartX, y: laserStartY - laserHeight / 2, width: laserWidth, height: laserHeight };
                 for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(laserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } }
                 if (boss && boss.onScreen && isColliding(laserRect, boss)) { if (boss.hit()) { boss = null; } } // ‚òÖ vs „Éú„Çπ
                 terrain.forEach(planet => { if (planet.checkCollisionWithRect(laserRect)) { /* Ë°ùÁ™ÅÂá¶ÁêÜ */ } });

                 // „Ç™„Éó„Ç∑„Éß„É≥„É¨„Éº„Ç∂„ÉºÂá¶ÁêÜ
                 options.forEach(option => { const optionLaserStartX = option.x + option.width; const optionLaserStartY = option.y + option.height / 2; ctx.fillText(LASER_TEXT, optionLaserStartX, optionLaserStartY); const optionLaserRect = { x: optionLaserStartX, y: optionLaserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(optionLaserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(optionLaserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(optionLaserRect)) { /* Ë°ùÁ™ÅÂá¶ÁêÜ */ } }); });
             }

            updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- „Ç≤„Éº„É†ÈñãÂßã ---
        init();

    </script>
</body>
</html>

