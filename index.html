<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIã‚³ãƒ¼ãƒ VS å­¦ç¿’ã—ãªã„çµ„ç¹” (v14 - æ—¥æœ¬èªåŒ–ãƒ»ç”»åƒè¡¨ç¤ºãƒ»ã‚­ãƒ¼å¤‰æ›´)</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">AIã‚³ãƒ¼ãƒ ãƒªãƒ•ãƒ¬ã‚¯ã“ VS å­¦ç¿’ã—ãªã„çµ„ç¹”
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js"></script>
    <style>
        /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš ã™ */
        }
        body {
            display: flex;
            flex-direction: column; /* ç¸¦ä¸¦ã³ */
            justify-content: center; /* ä¸­å¤®å¯„ã›ï¼ˆå‚ç›´ï¼‰ */
            align-items: center; /* ä¸­å¤®å¯„ã›ï¼ˆæ°´å¹³ï¼‰ */
            min-height: 100vh; /* ç”»é¢ã®é«˜ã•ã„ã£ã±ã„ã« */
        }

        /* ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒŠã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–è¨­å®š */
        #gameContainer {
            position: relative;
            /* â–¼â–¼â–¼ å¹…ã¨ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã§ã‚µã‚¤ã‚ºã‚’æ±ºå®š â–¼â–¼â–¼ */
            width: 95vw; /* ç”»é¢å¹…ã®95% */
            max-width: 960px; /* PCã§ã®æœ€å¤§å¹… */
            aspect-ratio: 16 / 10; /* ç¸¦æ¨ªæ¯”ã‚’16:10ã«å›ºå®š */
            max-height: 90vh; /* ç”»é¢é«˜ã•ã®90%ã‚’ä¸Šé™ã« */
            /* â–²â–²â–² å¹…ã¨ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã§ã‚µã‚¤ã‚ºã‚’æ±ºå®š â–²â–²â–² */
            border: 3px solid #fff;
            background-color: #000;
            overflow: hidden;
            margin: 10px auto; /* ä¸Šä¸‹ã«ãƒãƒ¼ã‚¸ãƒ³ã€å·¦å³ã¯è‡ªå‹•ã§ä¸­å¤®å¯„ã› */
            box-sizing: border-box;
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        canvas {
            display: block;
            width: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã„ã£ã±ã„ã«è¡¨ç¤º */
            height: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã„ã£ã±ã„ã«è¡¨ç¤º */
            background-color: #111;
            image-rendering: pixelated; /* ãƒ‰ãƒƒãƒˆçµµæ„Ÿã‚’ç¶­æŒ */
        }

        /* ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒãƒ¼ */
        #powerUpBar {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            padding: clamp(3px, 0.8vw, 5px); /* å¯å¤‰ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
            border: 2px solid #fff;
            border-radius: 5px;
            /* â–¼â–¼â–¼ å¹…ã¯JSã§ã‚³ãƒ³ãƒ†ãƒŠã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼ */
            width: 95vw; /* åˆæœŸå€¤ (JSã§ä¸Šæ›¸ã) */
            max-width: 960px; /* PCã§ã®æœ€å¤§å¹… */
            /* â–²â–²â–² å¹…ã¯JSã§ã‚³ãƒ³ãƒ†ãƒŠã«åˆã‚ã›ã‚‹ â–²â–²â–² */
            box-sizing: border-box;
            margin: 5px auto 0; /* ä¸Šãƒãƒ¼ã‚¸ãƒ³ã€å·¦å³ä¸­å¤® */
            flex-wrap: wrap; /* å°ç”»é¢ã§æŠ˜ã‚Šè¿”ã™å¯èƒ½æ€§ */
            gap: clamp(3px, 0.5vw, 5px); /* ã‚¢ã‚¤ãƒ†ãƒ é–“ã®éš™é–“ */
        }
        .powerUpItem {
            padding: clamp(3px, 0.8vw, 5px) clamp(5px, 1vw, 10px); /* å¯å¤‰ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
            border: 1px solid #555;
            color: #888;
            /* â–¼â–¼â–¼ ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¯å¤‰ã« â–¼â–¼â–¼ */
            font-size: clamp(8px, 1.5vw, 12px);
            /* â–²â–²â–² ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¯å¤‰ã« â–²â–²â–² */
            cursor: default;
            transition: all 0.2s ease;
            text-align: center;
            min-width: clamp(60px, 10vw, 90px); /* å¯å¤‰æœ€å°å¹… */
            white-space: nowrap;
            flex-grow: 1; /* ã‚¹ãƒšãƒ¼ã‚¹ãŒã‚ã‚Œã°åºƒãŒã‚‹ */
            flex-basis: 80px; /* åŸºæœ¬å¹… */
        }
        .powerUpItem.highlighted { background-color: #ffcc00; color: #000; border-color: #fff; box-shadow: 0 0 10px #ffcc00; }
        .powerUpItem.active { background-color: #ff6600; color: #fff; border-color: #fff; }

        /* UIãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆã‚¹ã‚³ã‚¢ã€ãƒ©ã‚¤ãƒ•ï¼‰ */
        #uiLayer {
            position: absolute;
            top: clamp(5px, 1vw, 10px); /* å¯å¤‰ */
            left: clamp(5px, 1vw, 10px); /* å¯å¤‰ */
            right: clamp(5px, 1vw, 10px); /* å¯å¤‰ */
            display: flex;
            justify-content: space-between;
            font-size: clamp(10px, 2vw, 16px); /* å¯å¤‰ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */
            pointer-events: none;
            text-shadow: 1px 1px 2px #000;
        }

        /* ãƒœã‚¹HPãƒãƒ¼ */
        #bossHpBar {
            position: absolute;
            bottom: clamp(5px, 1vw, 10px); /* å¯å¤‰ */
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 300px); /* å¯å¤‰å¹… */
            height: clamp(10px, 1.5vh, 15px); /* å¯å¤‰é«˜ã• */
            border: 2px solid #fff;
            background-color: #555;
            display: none;
            z-index: 5;
        }
        #bossHpFill { width: 100%; height: 100%; background-color: #ff4444; transition: width 0.2s ease-out; }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ */
        #messageBox {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); /* å°‘ã—æ¿ƒã */
            color: white;
            padding: clamp(15px, 3vw, 30px); /* å¯å¤‰ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
            border: 2px solid white;
            border-radius: 10px;
            font-size: clamp(14px, 3vw, 20px); /* å°‘ã—å°ã•ã */
            text-align: center;
            display: none;
            z-index: 10;
            width: 85%; /* å¹…ã‚’å°‘ã—åºƒã’ã‚‹ */
            max-width: 550px; /* æœ€å¤§å¹…ã‚‚å°‘ã—åºƒã’ã‚‹ */
            box-sizing: border-box;
        }
        /* â˜…â˜…â˜… ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹å†…ã®ç”»åƒã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
        #startImage {
            display: block; /* ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã«ã—ã¦ä¸­å¤®å¯„ã›ã—ã‚„ã™ã */
            margin: 10px auto 15px; /* ä¸Šä¸‹ã«ãƒãƒ¼ã‚¸ãƒ³ã€å·¦å³ä¸­å¤® */
            max-width: 80px; /* æœ€å¤§å¹… */
            max-height: 80px; /* æœ€å¤§é«˜ã• */
            border: 1px solid #555; /* æ ç·š */
            border-radius: 5px;
        }
        #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.5vw, 16px); /* å¯å¤‰ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */
            padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px); /* å¯å¤‰ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
            margin-top: clamp(10px, 2vh, 15px); /* å°‘ã—è©°ã‚ã‚‹ */
            cursor: pointer;
            background-color: #ffcc00;
            border: 2px solid #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #messageBox button:hover { background-color: #ffa500; }

        /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³æ¨ªå‘ãæ™‚ã®èª¿æ•´ */
        @media (max-width: 960px) and (orientation: landscape) {
            /* æ¨ªå‘ãã§ç‰¹ã«èª¿æ•´ãŒå¿…è¦ãªå ´åˆã“ã“ã«è¨˜è¿° */
        }
         @media (max-height: 480px) {
             /* ç¸¦å¹…ãŒç‰¹ã«å°ã•ã„ç”»é¢ã¸ã®å¯¾å¿œ */
             #gameContainer {
                 max-height: 95vh; /* é«˜ã•ã‚’ã•ã‚‰ã«ç¢ºä¿ */
             }
             #powerUpBar {
                 margin-top: 3px;
             }
             #uiLayer, #bossHpBar {
                 font-size: clamp(8px, 2vw, 12px); /* UIãƒ•ã‚©ãƒ³ãƒˆã‚’å°ã•ã */
             }
         }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: ğŸ’–ğŸ’–ğŸ’–</div>
        </div>
         <div id="bossHpBar"> <div id="bossHpFill"></div>
         </div>
         <div id="messageBox">
             <img id="startImage" src="refleko_right.png" alt="[Image of ãƒªãƒ•ãƒ¬ã‚¯ã“]">
             <div id="messageText"></div>
             <button id="restartButton">RESTART</button>
         </div>
    </div>
    <div id="powerUpBar">
        <div class="powerUpItem" id="productivity">ç”Ÿç”£æ€§UP</div>
        <div class="powerUpItem" id="inquiry">å•ã„ã‹ã‘</div>
        <div class="powerUpItem" id="aiFeedback">AIãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</div>
        <div class="powerUpItem" id="learningBeam">çµŒé¨“å­¦ç¿’ãƒ“ãƒ¼ãƒ </div>
        <div class="powerUpItem" id="aiAgent">AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</div>
        <div class="powerUpItem" id="safety">å¿ƒç†çš„å®‰å…¨æ€§</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const powerUpBar = document.getElementById('powerUpBar');
        const powerUpItems = powerUpBar.querySelectorAll('.powerUpItem');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const bossHpBar = document.getElementById('bossHpBar');
        const bossHpFill = document.getElementById('bossHpFill');
        // â˜…â˜…â˜… ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒè¦ç´ ã‚’å–å¾— â˜…â˜…â˜…
        const startImage = document.getElementById('startImage');

        let gameWidth, gameHeight; // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è§£åƒåº¦
        let stars = [];

        // --- ç”»åƒèª­ã¿è¾¼ã¿ ---
        const playerImage = new Image(); playerImage.src = 'refleko_right.png';
        let playerImageLoaded = false; playerImage.onload = () => { playerImageLoaded = true; console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); }; playerImage.onerror = () => { console.error("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); playerImage.src = 'https://placehold.co/40x40/0f0/fff?text=P'; };
        const optionImage = new Image(); optionImage.src = 'reflect_logo_3.png';
        let optionImageLoaded = false; optionImage.onload = () => { optionImageLoaded = true; console.log("ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); }; optionImage.onerror = () => { console.error("ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); optionImage.src = 'https://placehold.co/38x38/0af/fff?text=O'; };
        const bossImage = new Image(); bossImage.src = 'bigwork.png';
        let bossImageLoaded = false;
        bossImage.onload = () => { bossImageLoaded = true; console.log("ãƒœã‚¹ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚"); };
        bossImage.onerror = () => { console.error("ãƒœã‚¹ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); bossImage.src = 'https://placehold.co/200x200/800/fff?text=BOSS'; };
        // â˜…â˜…â˜… ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° â˜…â˜…â˜…
        startImage.onerror = () => {
            console.error("ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            startImage.alt = "[ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒèª­ã¿è¾¼ã¿å¤±æ•—]"; // ä»£æ›¿ãƒ†ã‚­ã‚¹ãƒˆ
            startImage.style.display = 'none'; // å¤±æ•—ã—ãŸã‚‰éè¡¨ç¤ºã«
        };


        // --- éŸ³å£°è¨­å®š ---
        const synth = new Tone.Synth().toDestination();
        const metalSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 0.5 }).toDestination();
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
        const bombSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 1.4, attackCurve: 'exponential' } }).toDestination();

        function playSound(type) {
             // (éŸ³å£°å†ç”Ÿãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—)
             if (!Tone.context.state || Tone.context.state !== 'running') { console.log("AudioContext is not running. Trying to resume..."); Tone.start().catch(e => console.error("Tone.start failed:", e)); }
             try { switch (type) { case 'shoot': synth.triggerAttackRelease("C5", "16n"); break; case 'enemyHit': noiseSynth.triggerAttackRelease("8n"); break; case 'playerHit': metalSynth.triggerAttackRelease("16n"); break; case 'powerupCollect': synth.triggerAttackRelease("E5", "8n"); break; case 'powerupActivate': synth.triggerAttackRelease("G5", "8n"); break; case 'gameOver': synth.triggerAttackRelease("C3", "4n", Tone.now()); synth.triggerAttackRelease("G2", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("E2", "4n", Tone.now() + 0.4); synth.triggerAttackRelease("C2", "2n", Tone.now() + 0.6); break; case 'missile': const missileNoise = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); missileNoise.triggerAttackRelease("8n"); break; case 'laser': synth.triggerAttackRelease("A5", "64n"); break; case 'enemyShoot': bombSynth.triggerAttackRelease("C2", "8n"); break; case 'bossHit': metalSynth.triggerAttackRelease("8n", 0.5); break; case 'bossDefeat': synth.triggerAttackRelease("C6", "2n", Tone.now()); synth.triggerAttackRelease("G5", "2n", Tone.now()+0.1); synth.triggerAttackRelease("E5", "2n", Tone.now()+0.2); synth.triggerAttackRelease("C5", "1n", Tone.now()+0.3); break; } } catch (error) { console.error("Error playing sound:", error); }
        }

        // --- ã‚²ãƒ¼ãƒ è¨­å®š (è¦ç´ ã®ã‚µã‚¤ã‚ºã¯å›ºå®šã®ã¾ã¾) ---
        let PLAYER_WIDTH = 40; let PLAYER_HEIGHT = 40; const PLAYER_SPEED_BASE = 3;
        const PROJECTILE_SPEED = 7; const PROJECTILE_FONT_SIZE = 20;
        const ENEMY_SPEED_BASE = 2; const ENEMY_SPAWN_RATE = 1000; const ENEMY_FONT_SIZE = 18;
        const ENEMY_PROJECTILE_SPEED = 3; const ENEMY_PROJECTILE_FONT_SIZE = 18;
        const POWERUP_ITEM_SPEED = 1.5; const POWERUP_ITEM_WIDTH = 12; const POWERUP_ITEM_HEIGHT = 20;
        const MISSILE_SPEED = 4; const MISSILE_FONT_SIZE = 20;
        const OPTION_WIDTH = 38; const OPTION_HEIGHT = 38;
        const ORBIT_RADIUS = 55;
        const ORBIT_SPEED = 0.05;
        const STAR_COUNT = 100; const STAR_SPEED_FACTOR = 0.5;
        const PLANET_SPAWN_RATE = 8000; const PLANET_SPEED = 0.5;
        const LASER_TEXT = "çµŒé¨“å­¦ç¿’-".repeat(7); const LASER_FONT_SIZE = 14;
        const BOSS_TRIGGER_SCORE = 15000;
        const BOSS_WIDTH = 200; const BOSS_HEIGHT = 200; const BOSS_MAX_HEALTH = 150;
        const BOSS_SHOOT_COOLDOWN = 1500; const BOSS_SCORE = 5000;

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ (å¤‰æ›´ãªã—) ---
        let player; let projectiles = []; let enemyProjectiles = []; let missiles = []; let enemies = []; let powerUpItemsList = []; let options = []; let terrain = [];
        let score = 0; let lives = 3; let gameOver = false; let gameWon = false;
        let gameRunning = false;
        let lastEnemySpawn = 0; lastPlanetSpawn = 0;
        let keys = {}; let currentPowerUpIndex = -1;
        let activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false };
        let shieldHp = 0;
        let laserActive = false;
        let enemySpawnPool = [];
        let bossModeActive = false;
        let boss = null;

        const powerUpTypes = ['productivity', 'inquiry', 'aiFeedback', 'learningBeam', 'aiAgent', 'safety'];

        // --- æ•µã®ç¨®é¡å®šç¾© (å¤‰æ›´ãªã—) ---
        const enemyTypes = {
            shortage: { text: "äººæ‰‹ä¸è¶³", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffdddd', health: 2, speedMultiplier: 0.9, value: 120, moveType: 'straight', dropChance: 0.15 * 1.5 },
            powerH: Â  { text: "ãƒ‘ãƒ¯ãƒãƒ©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffaaaa', health: 1, speedMultiplier: 1.2, value: 150, moveType: 'sine', dropChance: 0.2 * 1.5 },
            overtime: { text: "æ®‹æ¥­", Â  width: ENEMY_FONT_SIZE * 2, height: ENEMY_FONT_SIZE * 1.2, color: '#ddddff', health: 3, speedMultiplier: 0.7, value: 100, moveType: 'straight', dropChance: 0.1 * 1.5 },
            sexualH: Â { text: "ã‚»ã‚¯ãƒãƒ©", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#ffccff', health: 1, speedMultiplier: 1.1, value: 140, moveType: 'sine', dropChance: 0.18 * 1.5 },
            turnover: { text: "é«˜é›¢è·ç‡", width: ENEMY_FONT_SIZE * 5, height: ENEMY_FONT_SIZE * 1.2, color: '#ffffcc', health: 2, speedMultiplier: 1.0, value: 130, moveType: 'straight', dropChance: 0.22 * 1.5 },
            nonLearningOrg: { text: "å­¦ç¿’ã—ãªã„çµ„ç¹”", width: ENEMY_FONT_SIZE * 7, height: ENEMY_FONT_SIZE * 1.2, color: '#aaaaaa', health: 5, speedMultiplier: 0.6, value: 300, moveType: 'straight', dropChance: 0.15 * 1.5 },
            resistance: { text: "æŠµæŠ—å‹¢åŠ›", width: ENEMY_FONT_SIZE * 4, height: ENEMY_FONT_SIZE * 1.2, color: '#cc5555', health: 2, speedMultiplier: 0.5, value: 180, moveType: 'shooter', dropChance: 0.2 * 1.5, shootCooldown: 2500 }
        };

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ (æç”»åº§æ¨™ã¯ gameWidth/Height ã«ä¾å­˜) ---
        class Player {
            constructor(x, y) { this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT; this.speed = PLAYER_SPEED_BASE; this.shootCooldown = 0; this.missileCooldown = 0; this.laserDuration = 0; this.invincible = false; this.invincibleTimer = 0; }
            draw(ctx) {
                let drawPlayer = true;
                if (this.invincible) { drawPlayer = Math.floor(this.invincibleTimer / 100) % 2 === 0; }
                if (drawPlayer) {
                    if (playerImageLoaded) { ctx.drawImage(playerImage, this.x, this.y, this.width, this.height); }
                    else { ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10); ctx.fillStyle = '#000000'; ctx.fillRect(this.x + this.width / 2 - 2 , this.y + 5, 4, this.height - 10); }
                }
                if (activePowerUps.safety && shieldHp > 0) {
                    ctx.save(); ctx.globalAlpha = 0.5 + shieldHp * 0.25; ctx.strokeStyle = `rgba(0, 150, 255, 1)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 1.5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1;
                }
            }
            update() {
                if (this.invincible) { this.invincibleTimer -= 1000/60; if (this.invincibleTimer <= 0) { this.invincible = false; } }
                // â–¼â–¼â–¼ ç§»å‹•ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                if (keys['ArrowUp'] || keys['w']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s']) this.y += this.speed;
                if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d']) this.x += this.speed;
                this.x = Math.max(0, Math.min(this.x, gameWidth - this.width));
                this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                // â–²â–²â–² ç§»å‹•ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
                if (this.missileCooldown > 0) this.missileCooldown -= 16.67;
                if (this.laserDuration > 0) this.laserDuration -= 16.67; else laserActive = false;
                if ((keys[' '] || keys['z']) && this.shootCooldown <= 0) { this.shoot(); }
                if (activePowerUps.inquiry && this.missileCooldown <= 0) { this.fireMissile(); this.missileCooldown = 800; }
                options.forEach((option, index) => { option.update(this.x, this.y, index); });
            }
            shoot() {
                if (gameOver || gameWon) return;
                this.shootCooldown = activePowerUps.learningBeam ? 50 : 200;
                const projectileY = this.y + this.height / 2;
                if (activePowerUps.learningBeam) {
                    laserActive = true; this.laserDuration = 150; playSound('laser');
                } else {
                    projectiles.push(new Projectile(this.x + this.width, projectileY, 'player', 0, 'ğŸ’¬', PROJECTILE_FONT_SIZE));
                    playSound('shoot');
                    if (activePowerUps.aiFeedback) {
                        projectiles.push(new Projectile(this.x + this.width, projectileY - 10, 'player', Math.PI / 18, 'ğŸ’¬', PROJECTILE_FONT_SIZE));
                        projectiles.push(new Projectile(this.x + this.width, projectileY + 10, 'player', -Math.PI / 18, 'ğŸ’¬', PROJECTILE_FONT_SIZE));
                    }
                }
                options.forEach(option => option.shoot(activePowerUps.learningBeam));
            }
            fireMissile() {
                if (gameOver || gameWon) return;
                missiles.push(new Missile(this.x + this.width / 2, this.y + this.height, 'down'));
                missiles.push(new Missile(this.x + this.width / 2, this.y, 'up'));
                playSound('missile');
            }
            activatePowerUp() {
                if (currentPowerUpIndex !== -1) {
                    const selectedPowerUp = powerUpTypes[currentPowerUpIndex];
                    playSound('powerupActivate');
                    switch (selectedPowerUp) {
                        case 'productivity': activePowerUps.productivity++; this.speed = PLAYER_SPEED_BASE + activePowerUps.productivity * 1; break;
                        case 'inquiry': activePowerUps.inquiry = true; break;
                        case 'aiFeedback': activePowerUps.aiFeedback = true; activePowerUps.learningBeam = false; break;
                        case 'learningBeam': activePowerUps.learningBeam = true; activePowerUps.aiFeedback = false; break;
                        case 'aiAgent': if (activePowerUps.aiAgent < 2) { activePowerUps.aiAgent++; options.push(new Option(options.length)); } break;
                        case 'safety': activePowerUps.safety = true; shieldHp = 2; break;
                    }
                    updatePowerUpUI(); currentPowerUpIndex = -1; highlightPowerUp();
                }
            }
            hit() {
                if (this.invincible || gameWon) return;
                playSound('playerHit');
                if (activePowerUps.safety && shieldHp > 0) {
                    shieldHp--; this.setInvincible(500);
                    if (shieldHp <= 0) { activePowerUps.safety = false; const safetyElement = document.getElementById('safety'); if (safetyElement) safetyElement.classList.remove('active'); }
                    updatePowerUpUI(); return;
                }
                lives--; updateLivesDisplay(); resetPowerUps();
                if (lives <= 0) { gameOver = true; playSound('gameOver'); showGameOverMessage(); }
                // â–¼â–¼â–¼ å¾©æ´»ä½ç½®ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                else { this.x = 50; this.y = gameHeight / 2 - PLAYER_HEIGHT / 2; this.setInvincible(2000); }
                // â–²â–²â–² å¾©æ´»ä½ç½®ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
            }
            setInvincible(duration) { this.invincible = true; this.invincibleTimer = duration; }
        }

        // --- å¼¾ã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class Projectile {
            constructor(x, y, type, angle = 0, text = '?', fontSize = 16, speed = PROJECTILE_SPEED) { this.x = x; this.y = y; this.fontSize = fontSize; this.width = this.fontSize; this.height = this.fontSize; this.speed = speed; this.type = type; this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.text = text; }
            draw(ctx) { ctx.font = `${this.fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = this.type === 'player' ? '#ffffff' : '#ff5555'; ctx.fillText(this.text, this.x, this.y); }
            update() { this.x += this.vx; this.y += this.vy; }
        }

        // --- ãƒŸã‚µã‚¤ãƒ«ã‚¯ãƒ©ã‚¹ (å£åå°„ä½ç½®ã¯ gameHeight ã«ä¾å­˜) ---
        class Missile {
            constructor(x, y, direction) { this.x = x; this.y = y; this.fontSize = MISSILE_FONT_SIZE; this.width = this.fontSize; this.height = this.fontSize; this.speed = MISSILE_SPEED; this.direction = direction; }
            draw(ctx) { ctx.font = `bold ${this.fontSize}px "Press Start 2P"`; ctx.fillStyle = '#ffcc00'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ï¼Ÿ', this.x, this.y); }
            update() {
                // â–¼â–¼â–¼ å£åå°„ä½ç½®ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                if (this.direction === 'down') {
                    this.y += this.speed;
                    if (this.y > gameHeight - this.height / 2 - 5) { this.y = gameHeight - this.height / 2 - 5; this.x += this.speed / 2; this.direction = 'ground'; }
                } else { // 'up'
                    this.y -= this.speed;
                    if (this.y < this.height / 2 + 5) { this.y = this.height / 2 + 5; this.x += this.speed / 2; this.direction = 'ceiling'; }
                }
                // â–²â–²â–² å£åå°„ä½ç½®ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                if (this.direction === 'ground' || this.direction === 'ceiling') { this.x += this.speed / 1.5; }
             }
        }


        // --- æ•µã‚¯ãƒ©ã‚¹ (å‡ºç¾ä½ç½®ã€ç§»å‹•ç¯„å›²ã¯ gameWidth/Height ã«ä¾å­˜) ---
        class Enemy {
            constructor(y, typeName) {
                const type = enemyTypes[typeName] || enemyTypes.shortage;
                this.typeName = typeName; this.text = type.text; this.width = type.width; this.height = type.height;
                // â–¼â–¼â–¼ å‡ºç¾Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                this.x = gameWidth;
                // â–²â–²â–² å‡ºç¾Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                this.y = y; this.speed = (ENEMY_SPEED_BASE + Math.random() * 0.5) * type.speedMultiplier; this.color = type.color; this.health = type.health; this.value = type.value; this.moveType = type.moveType; this.amplitude = Math.random() * 40 + 10; this.frequency = Math.random() * 0.04 + 0.01; this.initialY = y; this.canDropPowerUp = Math.random() < type.dropChance; if (this.moveType === 'shooter') { this.shootCooldown = type.shootCooldown + (Math.random() * 500 - 250); this.lastShotTime = 0; }
            }
            draw(ctx) { ctx.font = `bold ${ENEMY_FONT_SIZE}px "Press Start 2P"`; ctx.fillStyle = this.color; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(this.text, this.x, this.y); }
            update(timestamp) {
                this.x -= this.speed;
                if (this.moveType === 'sine') {
                    // â–¼â–¼â–¼ Yåº§æ¨™ç§»å‹•ç¯„å›²ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                    this.y = this.initialY + Math.sin((gameWidth - this.x) * this.frequency) * this.amplitude;
                    this.y = Math.max(0, Math.min(this.y, gameHeight - this.height));
                    // â–²â–²â–² Yåº§æ¨™ç§»å‹•ç¯„å›²ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                } else if (this.moveType === 'shooter' && player) {
                    // â–¼â–¼â–¼ å°„æ’ƒé–‹å§‹Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                    if (this.x < gameWidth * 0.9 && this.x > 0 && timestamp - this.lastShotTime > this.shootCooldown) {
                    // â–²â–²â–² å°„æ’ƒé–‹å§‹Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                        this.shoot(); this.lastShotTime = timestamp; this.shootCooldown = enemyTypes[this.typeName].shootCooldown + (Math.random() * 500 - 250);
                    }
                }
            }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const targetX = player.x + player.width / 2; const targetY = player.y + player.height / 2; const dx = targetX - (this.x); const dy = targetY - (this.y + this.height / 2); const angle = Math.atan2(dy, dx); enemyProjectiles.push(new Projectile( this.x, this.y + this.height / 2, 'enemy', angle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED )); }
            hit() { this.health--; if (this.health <= 0) { addScore(this.value); playSound('enemyHit'); if (this.canDropPowerUp) { dropPowerUpItem(this.x + this.width / 2, this.y + this.height / 2); } return true; } const originalColor = this.color; this.color = '#ffffff'; setTimeout(() => { this.color = originalColor; }, 60); return false; }
        }

        // --- PowerUpItemã‚¯ãƒ©ã‚¹ (å¤‰æ›´ãªã—) ---
        class PowerUpItem {
            constructor(x, y) { this.x = x - POWERUP_ITEM_WIDTH / 2; this.y = y - POWERUP_ITEM_HEIGHT / 2; this.width = POWERUP_ITEM_WIDTH; this.height = POWERUP_ITEM_HEIGHT; this.speed = POWERUP_ITEM_SPEED; this.colorTop = '#aaaaee'; this.colorBody = '#4444ff'; this.colorAccent = '#ff4444'; this.sparkleOffset = 0; this.sparkleSpeed = 0.1; }
            draw(ctx, timestamp) { const topHeight = this.height * 0.2; const bodyHeight = this.height * 0.6; const bottomHeight = this.height * 0.2; ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y, this.width, topHeight); ctx.fillStyle = this.colorBody; ctx.fillRect(this.x, this.y + topHeight, this.width, bodyHeight); ctx.fillStyle = this.colorTop; ctx.fillRect(this.x, this.y + topHeight + bodyHeight, this.width, bottomHeight); ctx.fillStyle = this.colorAccent; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.2); ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2); ctx.lineTo(this.x + this.width / 2, this.y + topHeight + bodyHeight * 0.8); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("P", this.x + this.width / 2, this.y + this.height / 2 + 1); ctx.fillStyle = '#ffffaa'; const sparkleSize = 2; const sparkleDistance = Math.max(this.width, this.height) * 0.7; const angle1 = timestamp * 0.005 + this.sparkleOffset; const angle2 = timestamp * 0.005 + Math.PI / 2 + this.sparkleOffset; const angle3 = timestamp * 0.005 + Math.PI + this.sparkleOffset; const angle4 = timestamp * 0.005 + Math.PI * 1.5 + this.sparkleOffset; const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2; ctx.fillRect(centerX + Math.cos(angle1) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle1) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle2) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle2) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle3) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle3) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); ctx.fillRect(centerX + Math.cos(angle4) * sparkleDistance - sparkleSize / 2, centerY + Math.sin(angle4) * sparkleDistance - sparkleSize / 2, sparkleSize, sparkleSize); }
            update() { this.x -= this.speed; }
        }

        // --- Optionã‚¯ãƒ©ã‚¹ (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åº§æ¨™ã«ä¾å­˜) ---
        class Option {
            constructor(index = 0) { this.x = 0; this.y = 0; this.width = OPTION_WIDTH; this.height = OPTION_HEIGHT; this.size = Math.max(this.width, this.height); this.shootCooldown = 0; this.angle = index * Math.PI; }
            draw(ctx) { if (optionImageLoaded) { ctx.drawImage(optionImage, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.size / 2, 0, Math.PI * 2); ctx.fill(); } }
            update(playerX, playerY, index) {
                 this.angle += ORBIT_SPEED; if (this.angle > Math.PI * 2) { this.angle -= Math.PI * 2; }
                 const playerCenterX = playerX + PLAYER_WIDTH / 2; const playerCenterY = playerY + PLAYER_HEIGHT / 2;
                 const currentOrbitAngle = this.angle + index * Math.PI;
                 const targetX = playerCenterX + Math.cos(currentOrbitAngle) * ORBIT_RADIUS - this.width / 2;
                 const targetY = playerCenterY + Math.sin(currentOrbitAngle) * ORBIT_RADIUS - this.height / 2;
                 this.x = targetX; this.y = targetY;
                 if (this.shootCooldown > 0) this.shootCooldown -= 16.67;
             }
            shoot(isLaser) { if (this.shootCooldown <= 0) { this.shootCooldown = 200; const projectileY = this.y + this.height / 2; const projectileX = this.x + this.width; if (isLaser) { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, '?', PROJECTILE_FONT_SIZE)); playSound('laser'); } else { projectiles.push(new Projectile(projectileX, projectileY, 'player', 0, 'ğŸ’¬', PROJECTILE_FONT_SIZE)); playSound('shoot'); } } }
        }

        // --- Starã‚¯ãƒ©ã‚¹ (å‡ºç¾ç¯„å›²ã€ç§»å‹•ã¯ gameWidth/Height ã«ä¾å­˜) ---
        class Star {
            constructor() {
                // â–¼â–¼â–¼ å‡ºç¾ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                this.x = Math.random() * gameWidth;
                this.y = Math.random() * gameHeight;
                // â–²â–²â–² å‡ºç¾ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR;
            }
            draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
            update() {
                this.x -= this.speed;
                // â–¼â–¼â–¼ å†å‡ºç¾ä½ç½®ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                if (this.x < 0) { this.x = gameWidth; this.y = Math.random() * gameHeight; this.size = Math.random() * 1.5 + 0.5; this.speed = this.size * STAR_SPEED_FACTOR; }
                // â–²â–²â–² å†å‡ºç¾ä½ç½®ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
            }
        }

        // --- åœ°å½¢ã‚¯ãƒ©ã‚¹ (å‡ºç¾ä½ç½®ã¯ gameWidth ã«ä¾å­˜) ---
        class Planet {
            constructor(y, radius, color, speed) {
                // â–¼â–¼â–¼ å‡ºç¾Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                this.x = gameWidth + radius;
                // â–²â–²â–² å‡ºç¾Xåº§æ¨™ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                this.y = y; this.radius = radius; this.color = color; this.speed = speed;
             }
            draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; const numCraters = Math.floor(this.radius / 10); for (let i = 0; i < numCraters; i++) { const craterRadius = Math.random() * (this.radius * 0.15) + (this.radius * 0.05); const angle = Math.random() * Math.PI * 2; const dist = Math.random() * (this.radius - craterRadius); const craterX = this.x + Math.cos(angle) * dist; const craterY = this.y + Math.sin(angle) * dist; ctx.beginPath(); ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2); ctx.fill(); } }
            update() { this.x -= this.speed; }
            checkCollisionWithRect(rect) { const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width)); const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height)); const distanceX = this.x - closestX; const distanceY = this.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
            checkCollisionWithPoint(point) { const distanceX = this.x - point.x; const distanceY = this.y - point.y; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (this.radius * this.radius); }
        }

        // --- ãƒœã‚¹ã‚¯ãƒ©ã‚¹ (å‡ºç¾ä½ç½®ã€ç§»å‹•ç¯„å›²ã¯ gameWidth/Height ã«ä¾å­˜) ---
        class Boss {
            constructor() {
                this.width = BOSS_WIDTH; this.height = BOSS_HEIGHT;
                // â–¼â–¼â–¼ å‡ºç¾X,Yåº§æ¨™ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                this.x = gameWidth;
                this.y = gameHeight / 2 - this.height / 2;
                // â–²â–²â–² å‡ºç¾X,Yåº§æ¨™ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                this.speedX = 1.5; this.speedY = 1; this.maxHealth = BOSS_MAX_HEALTH; this.health = this.maxHealth; this.shootCooldown = BOSS_SHOOT_COOLDOWN; this.lastShotTime = 0; this.onScreen = false; this.targetY = this.y; this.hitFlashTimer = 0;
            }
            draw(ctx) {
                let currentImage = bossImage; if (this.hitFlashTimer > 0) { if (Math.floor(this.hitFlashTimer / 50) % 2 === 0) { ctx.globalAlpha = 0.5; } }
                if (bossImageLoaded) { ctx.drawImage(currentImage, this.x, this.y, this.width, this.height); }
                else { ctx.fillStyle = '#880000'; ctx.fillRect(this.x, this.y, this.width, this.height); }
                ctx.globalAlpha = 1.0; bossHpBar.style.display = 'block'; const hpPercentage = Math.max(0, this.health / this.maxHealth) * 100; bossHpFill.style.width = `${hpPercentage}%`;
            }
            update(timestamp) {
                if (this.hitFlashTimer > 0) { this.hitFlashTimer -= 1000 / 60; }
                if (!this.onScreen) {
                    this.x -= this.speedX;
                    // â–¼â–¼â–¼ ç”»é¢å†…åœæ­¢ä½ç½®ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                    if (this.x <= gameWidth - this.width - 50) { this.x = gameWidth - this.width - 50; this.onScreen = true; this.lastShotTime = timestamp; }
                    // â–²â–²â–² ç”»é¢å†…åœæ­¢ä½ç½®ã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                } else {
                    // â–¼â–¼â–¼ Yåº§æ¨™ç§»å‹•ç¯„å›²ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                    this.y += this.speedY;
                    if (this.y <= 0 || this.y + this.height >= gameHeight) { this.speedY *= -1; this.y = Math.max(0, Math.min(this.y, gameHeight - this.height)); }
                    // â–²â–²â–² Yåº§æ¨™ç§»å‹•ç¯„å›²ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                    if (timestamp - this.lastShotTime > this.shootCooldown) { this.shoot(); this.lastShotTime = timestamp; }
                }
            }
            shoot() { if (!player || gameOver || gameWon) return; playSound('enemyShoot'); const shootX = this.x; const shootY = this.y + this.height / 2; const angleToPlayer = Math.atan2(player.y + player.height / 2 - shootY, player.x + player.width / 2 - shootX); const spreadAngle = Math.PI / 9; enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer - spreadAngle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); enemyProjectiles.push(new Projectile(shootX, shootY, 'enemy', angleToPlayer + spreadAngle, 'ğŸ’£', ENEMY_PROJECTILE_FONT_SIZE, ENEMY_PROJECTILE_SPEED)); }
            hit() { if (this.health <= 0) return false; this.health--; playSound('bossHit'); this.hitFlashTimer = 150; if (this.health <= 0) { addScore(BOSS_SCORE); playSound('bossDefeat'); bossHpBar.style.display = 'none'; gameWon = true; showGameWonMessage(); return true; } return false; }
        }


        // --- åˆæœŸåŒ– ---
        function init() {
            // â–¼â–¼â–¼ resizeCanvas ã‚’æœ€åˆã«å‘¼ã³å‡ºã™ â–¼â–¼â–¼
            resizeCanvas();
            // â–²â–²â–² resizeCanvas ã‚’æœ€åˆã«å‘¼ã³å‡ºã™ â–²â–²â–²
            player = new Player(50, gameHeight / 2 - PLAYER_HEIGHT / 2); // gameHeight ã‚’ä½¿ã†
            projectiles = []; enemyProjectiles = []; missiles = []; enemies = []; powerUpItemsList = []; options = []; terrain = [];
            score = 0; lives = 3; gameOver = false; gameWon = false;
            gameRunning = false; lastEnemySpawn = 0; lastPlanetSpawn = 0;
            keys = {}; currentPowerUpIndex = -1; resetPowerUps(false); shieldHp = 0; laserActive = false;
            bossModeActive = false; boss = null; bossHpBar.style.display = 'none';

            updateScoreDisplay(); updateLivesDisplay(); updatePowerUpUI(); highlightPowerUp();
            messageBox.style.display = 'none';
            // â–¼â–¼â–¼ æ˜Ÿã®åˆæœŸåŒ–ã‚‚ resizeCanvas å¾Œã«è¡Œã† â–¼â–¼â–¼
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push(new Star()); // Starã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒ gameWidth/Height ã‚’ä½¿ã†
            }
            // â–²â–²â–² æ˜Ÿã®åˆæœŸåŒ–ã‚‚ resizeCanvas å¾Œã«è¡Œã† â–²â–²â–²
            enemySpawnPool = []; Object.keys(enemyTypes).forEach(key => { const weight = (key === 'resistance') ? 1 : 2; for (let i = 0; i < weight; i++) { enemySpawnPool.push(key); } });
            showStartMessage(); const newRestartButton = restartButton.cloneNode(true); restartButton.parentNode.replaceChild(newRestartButton, restartButton); document.getElementById('restartButton').addEventListener('click', startGame);
            window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); window.removeEventListener('resize', handleResize); // â˜… ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ©ã‚’å¤‰æ›´
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', handleResize); // â˜… ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã«æ–°ã—ã„ãƒãƒ³ãƒ‰ãƒ©ã‚’è¨­å®š
            window.addEventListener('orientationchange', handleResize); // â˜… ç”»é¢å›è»¢ã‚¤ãƒ™ãƒ³ãƒˆã«ã‚‚å¯¾å¿œ
        }

        // --- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºé–¢æ•° ---
        function showStartMessage() {
            // â˜…â˜…â˜… æ—¥æœ¬èªã®èª¬æ˜æ–‡ã«å¤‰æ›´ â˜…â˜…â˜…
            messageText.innerHTML = "AIã‚³ãƒ¼ãƒ VS å­¦ç¿’ã—ãªã„çµ„ç¹”<br>" +
                                    "æ“ä½œæ–¹æ³•:<br>" +
                                    "ç§»å‹•: çŸ¢å°ã‚­ãƒ¼ / WASD<br>" +
                                    "ã‚·ãƒ§ãƒƒãƒˆ: Space / Z<br>" +
                                    "ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ç™ºå‹•: Shift + R<br><br>" + // â˜…â˜…â˜… ã‚­ãƒ¼èª¬æ˜ã‚’å¤‰æ›´ â˜…â˜…â˜…
                                    "ä¸‹ã®ãƒœã‚¿ãƒ³ã§ã‚²ãƒ¼ãƒ é–‹å§‹";
            const startButton = document.getElementById('restartButton');
            startButton.textContent = "ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ"; // ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚‚æ—¥æœ¬èªã«
            // â˜…â˜…â˜… ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒã‚’è¡¨ç¤º â˜…â˜…â˜…
            startImage.style.display = 'block';
            messageBox.style.display = 'block';
            gameRunning = false;
        }
        function showGameOverMessage() {
            messageText.innerHTML = `ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼<br>æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ";
            startImage.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯ç”»åƒã‚’éè¡¨ç¤º
            messageBox.style.display = 'block';
            gameRunning = false;
        }
        function showGameWonMessage() {
            messageText.innerHTML = `ã‚¯ãƒªã‚¢ï¼<br>ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼<br>æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}`;
            const restartBtn = document.getElementById('restartButton');
            restartBtn.textContent = "ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤";
            startImage.style.display = 'none'; // ã‚¯ãƒªã‚¢æ™‚ã‚‚ç”»åƒã‚’éè¡¨ç¤º
            messageBox.style.display = 'block';
            gameRunning = false;
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•° ---
        function startGame() {
            if (Tone.context.state !== 'running') {
                Tone.start().catch(e => console.error("Tone.start failed:", e));
            }
            messageBox.style.display = 'none';
            // â˜…â˜…â˜… ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã«ç”»åƒã‚’éè¡¨ç¤º â˜…â˜…â˜…
            startImage.style.display = 'none';
            if (gameOver || gameWon) {
                init(); // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢å¾Œã®å†ã‚¹ã‚¿ãƒ¼ãƒˆãªã‚‰åˆæœŸåŒ–
            }
            gameOver = false;
            gameWon = false;
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // --- ãƒªã‚µã‚¤ã‚ºå‡¦ç† ---
        // â–¼â–¼â–¼ ãƒªã‚µã‚¤ã‚ºå‡¦ç†ã‚’æ›´æ–° â–¼â–¼â–¼
        function resizeCanvas() {
            // gameContainer ã®å®Ÿéš›ã®è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’å–å¾—
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è§£åƒåº¦ï¼ˆå†…éƒ¨çš„ãªæç”»ã‚µã‚¤ã‚ºï¼‰ã‚’è¨­å®š
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            // ã‚²ãƒ¼ãƒ å†…ã§ä½¿ç”¨ã™ã‚‹å¹…ã¨é«˜ã•ã‚’æ›´æ–°
            gameWidth = canvas.width;
            gameHeight = canvas.height;

            // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒãƒ¼ã®å¹…ã‚’ã‚³ãƒ³ãƒ†ãƒŠã«åˆã‚ã›ã‚‹
            powerUpBar.style.width = `${containerWidth}px`;
            powerUpBar.style.maxWidth = '960px'; // æœ€å¤§å¹…ã‚‚è¨­å®š

            // æ˜Ÿã®ä½ç½®ã‚’å†è¨ˆç®—ï¼ˆç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«ï¼‰
            stars.forEach(star => {
                star.x = Math.min(star.x, gameWidth);
                star.y = Math.min(star.y, gameHeight);
            });

            console.log(`Resized canvas to: ${gameWidth}x${gameHeight}`);
        }

        // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã®ãƒãƒ³ãƒ‰ãƒ©ï¼ˆå°‘ã—é…å»¶ã•ã›ã¦å®Ÿè¡Œï¼‰
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                // å¿…è¦ã§ã‚ã‚Œã°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ãªã©ã‚’å†èª¿æ•´
                if (player) {
                     player.x = Math.min(player.x, gameWidth - player.width);
                     player.y = Math.min(player.y, gameHeight - player.height);
                }
            }, 100); // 100ms ã®é…å»¶
        }
        // â–²â–²â–² ãƒªã‚µã‚¤ã‚ºå‡¦ç†ã‚’æ›´æ–° â–²â–²â–²

        // --- ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—å‡¦ç† (å¤‰æ›´ãªã—) ---
        function collectPowerUp() { playSound('powerupCollect'); currentPowerUpIndex = (currentPowerUpIndex + 1) % powerUpTypes.length; highlightPowerUp(); }
        function highlightPowerUp() { powerUpItems.forEach((item, index) => { item.classList.toggle('highlighted', index === currentPowerUpIndex); }); }
        function updatePowerUpUI() {
            powerUpTypes.forEach((type) => {
                const element = document.getElementById(type);
                if (element) {
                    let isActive = false;
                    let text = element.textContent.split(' (')[0]; // å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
                    switch(type) {
                        case 'productivity': isActive = activePowerUps.productivity > 0; text = isActive ? `ç”Ÿç”£æ€§UP (${activePowerUps.productivity})` : 'ç”Ÿç”£æ€§UP'; break;
                        case 'aiAgent': isActive = activePowerUps.aiAgent > 0; text = isActive ? `AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (${activePowerUps.aiAgent})` : 'AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ'; break;
                        case 'safety': isActive = activePowerUps.safety; text = isActive ? `å¿ƒç†çš„å®‰å…¨æ€§ (${shieldHp})` : 'å¿ƒç†çš„å®‰å…¨æ€§'; break;
                        case 'inquiry': isActive = activePowerUps.inquiry; text = 'å•ã„ã‹ã‘'; break;
                        case 'aiFeedback': isActive = activePowerUps.aiFeedback; text = 'AIãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯'; break;
                        case 'learningBeam': isActive = activePowerUps.learningBeam; text = 'çµŒé¨“å­¦ç¿’ãƒ“ãƒ¼ãƒ '; break;
                    }
                    element.classList.toggle('active', isActive); element.textContent = text;
                }
            });
        }
        function resetPowerUps(updateUI = true) {
            activePowerUps = { productivity: 0, inquiry: false, aiFeedback: false, learningBeam: false, aiAgent: 0, safety: false };
            if (player) player.speed = PLAYER_SPEED_BASE;
            options = []; shieldHp = 0; laserActive = false; currentPowerUpIndex = -1;
            if(updateUI) { updatePowerUpUI(); highlightPowerUp(); }
        }
        function dropPowerUpItem(x, y) { powerUpItemsList.push(new PowerUpItem(x, y)); }

        // --- ã‚¹ã‚³ã‚¢ãƒ»ãƒ©ã‚¤ãƒ•æ›´æ–° (å¤‰æ›´ãªã—) ---
        function addScore(amount) {
            if (gameOver || gameWon) return; score += amount; updateScoreDisplay();
            if (!bossModeActive && score >= BOSS_TRIGGER_SCORE) {
                bossModeActive = true; enemies = []; terrain = []; enemyProjectiles = []; powerUpItemsList = [];
                boss = new Boss(); console.log("BOSS MODE ACTIVATED!");
            }
        }
        function updateScoreDisplay() { scoreDisplay.textContent = `SCORE: ${score}`; }
        function updateLivesDisplay() { livesDisplay.innerHTML = `LIVES: ${'ğŸ’–'.repeat(lives)}`; }

        // --- è¡çªåˆ¤å®š (åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã¯ gameWidth/Height ã«ä¾å­˜) ---
        function checkCollisions() {
            if (!player) return;

            // åœ°å½¢ã¨ã®è¡çª
            terrain.forEach(planet => {
                if (!player.invincible && planet.checkCollisionWithRect(player)) { player.hit(); }
                projectiles = projectiles.filter(proj => !(proj.type === 'player' && planet.checkCollisionWithPoint(proj)));
                enemyProjectiles = enemyProjectiles.filter(proj => !planet.checkCollisionWithPoint(proj));
                missiles = missiles.filter(missile => !planet.checkCollisionWithPoint({ x: missile.x, y: missile.direction === 'down' ? missile.y + missile.height : missile.y - missile.height }));
            });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ vs æ•µ/ãƒœã‚¹
            projectiles = projectiles.filter(proj => {
                if (proj.type !== 'player') return true;
                const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (isColliding(projHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; }
                }
                if (boss && boss.onScreen && isColliding(projHitbox, boss)) { if (boss.hit()) { boss = null; } return false; }
                // â–¼â–¼â–¼ ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                return proj.x < gameWidth + proj.width;
                // â–²â–²â–² ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth ã«åˆã‚ã›ã‚‹ â–²â–²â–²
            });

            // æ•µå¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            enemyProjectiles = enemyProjectiles.filter(proj => {
                 const projHitbox = { x: proj.x - proj.width / 2, y: proj.y - proj.height / 2, width: proj.width, height: proj.height };
                 if (!player.invincible && isColliding(projHitbox, player)) { player.hit(); return false; }
                 // â–¼â–¼â–¼ ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                 return proj.x > -proj.width && proj.x < gameWidth + proj.width && proj.y > -proj.height && proj.y < gameHeight + proj.height;
                 // â–²â–²â–² ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
             });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒŸã‚µã‚¤ãƒ« vs æ•µ/ãƒœã‚¹
             missiles = missiles.filter(missile => {
                 const missileHitbox = { x: missile.x - missile.width / 2, y: missile.y - missile.height / 2, width: missile.width, height: missile.height };
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (isColliding(missileHitbox, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } return false; }
                 }
                 if (boss && boss.onScreen && isColliding(missileHitbox, boss)) { if (boss.hit()) { boss = null; } return false; }
                 // â–¼â–¼â–¼ ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                 return missile.x < gameWidth + 50 && missile.x > -missile.width && missile.y < gameHeight + 50 && missile.y > -missile.height;
                 // â–²â–²â–² ç”»é¢å¤–åˆ¤å®šã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
              });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs æ•µ/ãƒœã‚¹
            if (!player.invincible) {
                enemies.forEach((enemy, index) => { if (isColliding(player, enemy)) { player.hit(); if (enemy.hit()) { enemies.splice(index, 1); } } });
                if (boss && boss.onScreen && isColliding(player, boss)) { player.hit(); }
            }

             // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
             powerUpItemsList = powerUpItemsList.filter(item => { if (isColliding(player, item)) { collectPowerUp(); return false; } return item.x > -item.width; });

             // ãƒ¬ãƒ¼ã‚¶ãƒ¼ vs æ•µ/ãƒœã‚¹ (åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—ã€æç”»åº§æ¨™ã«ä¾å­˜)
        }
        function isColliding(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ› ---
        function handleKeyDown(e) {
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºä¸­ã¯ç‰¹å®šã®ã‚­ãƒ¼æ“ä½œã‚’åˆ¶é™
            if (!gameRunning && messageBox.style.display === 'block') {
                // Shift+R ã‚„ Space/Z ã¯ç„¡åŠ¹åŒ–
                if ((e.shiftKey && e.key.toLowerCase() === 'r') || e.key === ' ' || e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    return;
                }
            } else if (gameRunning) {
                keys[e.key] = true;
                // â˜…â˜…â˜… ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ç™ºå‹•ã‚­ãƒ¼ã‚’ Shift + R ã«å¤‰æ›´ â˜…â˜…â˜…
                if (e.shiftKey && e.key.toLowerCase() === 'r' && !e.repeat) {
                    player.activatePowerUp();
                }
                // ã‚¹ãƒšãƒ¼ã‚¹ã¾ãŸã¯Zã‚­ãƒ¼ã®å‡¦ç† (å¤‰æ›´ãªã—)
                if (e.key === ' ' || e.key.toLowerCase() === 'z') {
                    keys[e.key] = true; // æŠ¼ã—ã£ã±ãªã—å¯¾å¿œ
                }
            }
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã©ã‚’é˜²ãã‚­ãƒ¼
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'r', 'w', 'a', 's', 'd'].includes(e.key)) { // 'x' ã‚’ 'r' ã«å¤‰æ›´
                e.preventDefault();
            }
        }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— (æç”»/æ›´æ–°ã¯ gameWidth/Height ã«ä¾å­˜) ---
        function gameLoop(timestamp) {
            if (gameOver || gameWon || !gameRunning) { return; }

            // ã‚¹ãƒãƒ¼ãƒ³å‡¦ç† (ãƒœã‚¹ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯åœæ­¢)
            if (!bossModeActive) {
                // â–¼â–¼â–¼ æ•µã®å‡ºç¾Yåº§æ¨™ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                if (timestamp - lastEnemySpawn > ENEMY_SPAWN_RATE) { lastEnemySpawn = timestamp; if (enemySpawnPool.length > 0) { const randomPoolIndex = Math.floor(Math.random() * enemySpawnPool.length); const randomTypeKey = enemySpawnPool[randomPoolIndex]; const enemyType = enemyTypes[randomTypeKey]; const enemyY = Math.random() * (gameHeight - enemyType.height); enemies.push(new Enemy(enemyY, randomTypeKey)); } }
                // â–²â–²â–² æ•µã®å‡ºç¾Yåº§æ¨™ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
                // â–¼â–¼â–¼ åœ°å½¢ã®å‡ºç¾Yåº§æ¨™ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
                if (timestamp - lastPlanetSpawn > PLANET_SPAWN_RATE) { lastPlanetSpawn = timestamp; const radius = Math.random() * 50 + 40; const y = Math.random() * (gameHeight - radius * 2) + radius; const color = `hsl(${Math.random() * 60 + 180}, 50%, ${Math.random() * 30 + 40}%)`; const speed = PLANET_SPEED * (Math.random() * 0.5 + 0.75); terrain.push(new Planet(y, radius, color, speed)); }
                // â–²â–²â–² åœ°å½¢ã®å‡ºç¾Yåº§æ¨™ã‚’ gameHeight ã«åˆã‚ã›ã‚‹ â–²â–²â–²
            }

            // æ›´æ–°å‡¦ç†
            if(player) player.update();
            projectiles.forEach(p => p.update());
            enemyProjectiles.forEach(p => p.update());
            missiles.forEach(m => m.update());
            enemies.forEach(e => e.update(timestamp));
            powerUpItemsList.forEach(p => p.update());
            stars.forEach(s => s.update());
            terrain = terrain.filter(t => t.x > -t.radius * 2);
            terrain.forEach(t => t.update());
            if (boss) boss.update(timestamp);

            // è¡çªåˆ¤å®š
            checkCollisions();

            // æç”»å‡¦ç†
            // â–¼â–¼â–¼ æç”»ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–¼â–¼â–¼
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            // â–²â–²â–² æç”»ç¯„å›²ã‚’ gameWidth/Height ã«åˆã‚ã›ã‚‹ â–²â–²â–²
            stars.forEach(s => s.draw(ctx));
            terrain.forEach(t => t.draw(ctx));

            if(player) player.draw(ctx);
            options.forEach(o => o.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            enemyProjectiles.forEach(p => p.draw(ctx));
            missiles.forEach(m => m.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            powerUpItemsList.forEach(p => p.draw(ctx, timestamp));
            if (boss) boss.draw(ctx);

            // ãƒ¬ãƒ¼ã‚¶ãƒ¼æç”»ã¨è¡çªåˆ¤å®š (å¤‰æ›´ãªã—)
             if (laserActive && player) {
                 ctx.font = `bold ${LASER_FONT_SIZE}px sans-serif`; ctx.fillStyle = '#00aaff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                 const textMetrics = ctx.measureText(LASER_TEXT); const laserWidth = textMetrics.width; const laserHeight = LASER_FONT_SIZE;
                 const laserStartX = player.x + player.width; const laserStartY = player.y + player.height / 2; ctx.fillText(LASER_TEXT, laserStartX, laserStartY); const laserRect = { x: laserStartX, y: laserStartY - laserHeight / 2, width: laserWidth, height: laserHeight };
                 for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(laserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } }
                 if (boss && boss.onScreen && isColliding(laserRect, boss)) { if (boss.hit()) { boss = null; } }
                 terrain.forEach(planet => { if (planet.checkCollisionWithRect(laserRect)) { /* è¡çªå‡¦ç† */ } });
                 options.forEach(option => { const optionLaserStartX = option.x + option.width; const optionLaserStartY = option.y + option.height / 2; ctx.fillText(LASER_TEXT, optionLaserStartX, optionLaserStartY); const optionLaserRect = { x: optionLaserStartX, y: optionLaserStartY - laserHeight / 2, width: laserWidth, height: laserHeight }; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (isColliding(optionLaserRect, enemy)) { if (enemy.hit()) { enemies.splice(i, 1); } } } if (boss && boss.onScreen && isColliding(optionLaserRect, boss)) { if (boss.hit()) { boss = null; } } terrain.forEach(planet => { if (planet.checkCollisionWithRect(optionLaserRect)) { /* è¡çªå‡¦ç† */ } }); });
             }

            updatePowerUpUI();

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        init(); // åˆæœŸåŒ–å‡¦ç†ã‚’å®Ÿè¡Œ

    </script>
</body>
</html>
